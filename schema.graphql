schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "categories"
"""
type categories {
  created_at: timestamptz!
  description: String
  id: uuid!
  name: String!
  updated_at: timestamptz!
  user_id: String!
}

"""
aggregated selection of "categories"
"""
type categories_aggregate {
  aggregate: categories_aggregate_fields
  nodes: [categories!]!
}

"""
aggregate fields of "categories"
"""
type categories_aggregate_fields {
  count(columns: [categories_select_column!], distinct: Boolean): Int
  max: categories_max_fields
  min: categories_min_fields
}

"""
order by aggregate values of table "categories"
"""
input categories_aggregate_order_by {
  count: order_by
  max: categories_max_order_by
  min: categories_min_order_by
}

"""
input type for inserting array relation for remote table "categories"
"""
input categories_arr_rel_insert_input {
  data: [categories_insert_input!]!
  on_conflict: categories_on_conflict
}

"""
Boolean expression to filter rows from the table "categories". All fields are combined with a logical 'AND'.
"""
input categories_bool_exp {
  _and: [categories_bool_exp]
  _not: categories_bool_exp
  _or: [categories_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "categories"
"""
enum categories_constraint {
  """unique or primary key constraint"""
  categories_pkey
}

"""
input type for inserting data into table "categories"
"""
input categories_insert_input {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type categories_max_fields {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "categories"
"""
input categories_max_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type categories_min_fields {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "categories"
"""
input categories_min_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "categories"
"""
type categories_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [categories!]!
}

"""
input type for inserting object relation for remote table "categories"
"""
input categories_obj_rel_insert_input {
  data: categories_insert_input!
  on_conflict: categories_on_conflict
}

"""
on conflict condition type for table "categories"
"""
input categories_on_conflict {
  constraint: categories_constraint!
  update_columns: [categories_update_column!]!
  where: categories_bool_exp
}

"""
ordering options when selecting data from "categories"
"""
input categories_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "categories"
"""
input categories_pk_columns_input {
  id: uuid!
}

"""
select columns of table "categories"
"""
enum categories_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "categories"
"""
input categories_set_input {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
update columns of table "categories"
"""
enum categories_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
columns and relationships of "dishes"
"""
type dishes {
  carbs: Int
  created_at: timestamptz!
  description: String
  fat: Int
  id: uuid!
  name: String!
  protein: Int
  quantity: Int
  unit: String
  updated_at: timestamptz!
  user_id: String
}

"""
aggregated selection of "dishes"
"""
type dishes_aggregate {
  aggregate: dishes_aggregate_fields
  nodes: [dishes!]!
}

"""
aggregate fields of "dishes"
"""
type dishes_aggregate_fields {
  avg: dishes_avg_fields
  count(columns: [dishes_select_column!], distinct: Boolean): Int
  max: dishes_max_fields
  min: dishes_min_fields
  stddev: dishes_stddev_fields
  stddev_pop: dishes_stddev_pop_fields
  stddev_samp: dishes_stddev_samp_fields
  sum: dishes_sum_fields
  var_pop: dishes_var_pop_fields
  var_samp: dishes_var_samp_fields
  variance: dishes_variance_fields
}

"""
order by aggregate values of table "dishes"
"""
input dishes_aggregate_order_by {
  avg: dishes_avg_order_by
  count: order_by
  max: dishes_max_order_by
  min: dishes_min_order_by
  stddev: dishes_stddev_order_by
  stddev_pop: dishes_stddev_pop_order_by
  stddev_samp: dishes_stddev_samp_order_by
  sum: dishes_sum_order_by
  var_pop: dishes_var_pop_order_by
  var_samp: dishes_var_samp_order_by
  variance: dishes_variance_order_by
}

"""
input type for inserting array relation for remote table "dishes"
"""
input dishes_arr_rel_insert_input {
  data: [dishes_insert_input!]!
  on_conflict: dishes_on_conflict
}

"""aggregate avg on columns"""
type dishes_avg_fields {
  carbs: Float
  fat: Float
  protein: Float
  quantity: Float
}

"""
order by avg() on columns of table "dishes"
"""
input dishes_avg_order_by {
  carbs: order_by
  fat: order_by
  protein: order_by
  quantity: order_by
}

"""
Boolean expression to filter rows from the table "dishes". All fields are combined with a logical 'AND'.
"""
input dishes_bool_exp {
  _and: [dishes_bool_exp]
  _not: dishes_bool_exp
  _or: [dishes_bool_exp]
  carbs: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  fat: Int_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  protein: Int_comparison_exp
  quantity: Int_comparison_exp
  unit: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "dishes"
"""
enum dishes_constraint {
  """unique or primary key constraint"""
  dishes_pkey
}

"""
input type for incrementing integer column in table "dishes"
"""
input dishes_inc_input {
  carbs: Int
  fat: Int
  protein: Int
  quantity: Int
}

"""
input type for inserting data into table "dishes"
"""
input dishes_insert_input {
  carbs: Int
  created_at: timestamptz
  description: String
  fat: Int
  id: uuid
  name: String
  protein: Int
  quantity: Int
  unit: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type dishes_max_fields {
  carbs: Int
  created_at: timestamptz
  description: String
  fat: Int
  id: uuid
  name: String
  protein: Int
  quantity: Int
  unit: String
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "dishes"
"""
input dishes_max_order_by {
  carbs: order_by
  created_at: order_by
  description: order_by
  fat: order_by
  id: order_by
  name: order_by
  protein: order_by
  quantity: order_by
  unit: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type dishes_min_fields {
  carbs: Int
  created_at: timestamptz
  description: String
  fat: Int
  id: uuid
  name: String
  protein: Int
  quantity: Int
  unit: String
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "dishes"
"""
input dishes_min_order_by {
  carbs: order_by
  created_at: order_by
  description: order_by
  fat: order_by
  id: order_by
  name: order_by
  protein: order_by
  quantity: order_by
  unit: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "dishes"
"""
type dishes_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [dishes!]!
}

"""
input type for inserting object relation for remote table "dishes"
"""
input dishes_obj_rel_insert_input {
  data: dishes_insert_input!
  on_conflict: dishes_on_conflict
}

"""
on conflict condition type for table "dishes"
"""
input dishes_on_conflict {
  constraint: dishes_constraint!
  update_columns: [dishes_update_column!]!
  where: dishes_bool_exp
}

"""
ordering options when selecting data from "dishes"
"""
input dishes_order_by {
  carbs: order_by
  created_at: order_by
  description: order_by
  fat: order_by
  id: order_by
  name: order_by
  protein: order_by
  quantity: order_by
  unit: order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "dishes"
"""
input dishes_pk_columns_input {
  id: uuid!
}

"""
select columns of table "dishes"
"""
enum dishes_select_column {
  """column name"""
  carbs

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  fat

  """column name"""
  id

  """column name"""
  name

  """column name"""
  protein

  """column name"""
  quantity

  """column name"""
  unit

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "dishes"
"""
input dishes_set_input {
  carbs: Int
  created_at: timestamptz
  description: String
  fat: Int
  id: uuid
  name: String
  protein: Int
  quantity: Int
  unit: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type dishes_stddev_fields {
  carbs: Float
  fat: Float
  protein: Float
  quantity: Float
}

"""
order by stddev() on columns of table "dishes"
"""
input dishes_stddev_order_by {
  carbs: order_by
  fat: order_by
  protein: order_by
  quantity: order_by
}

"""aggregate stddev_pop on columns"""
type dishes_stddev_pop_fields {
  carbs: Float
  fat: Float
  protein: Float
  quantity: Float
}

"""
order by stddev_pop() on columns of table "dishes"
"""
input dishes_stddev_pop_order_by {
  carbs: order_by
  fat: order_by
  protein: order_by
  quantity: order_by
}

"""aggregate stddev_samp on columns"""
type dishes_stddev_samp_fields {
  carbs: Float
  fat: Float
  protein: Float
  quantity: Float
}

"""
order by stddev_samp() on columns of table "dishes"
"""
input dishes_stddev_samp_order_by {
  carbs: order_by
  fat: order_by
  protein: order_by
  quantity: order_by
}

"""aggregate sum on columns"""
type dishes_sum_fields {
  carbs: Int
  fat: Int
  protein: Int
  quantity: Int
}

"""
order by sum() on columns of table "dishes"
"""
input dishes_sum_order_by {
  carbs: order_by
  fat: order_by
  protein: order_by
  quantity: order_by
}

"""
update columns of table "dishes"
"""
enum dishes_update_column {
  """column name"""
  carbs

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  fat

  """column name"""
  id

  """column name"""
  name

  """column name"""
  protein

  """column name"""
  quantity

  """column name"""
  unit

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type dishes_var_pop_fields {
  carbs: Float
  fat: Float
  protein: Float
  quantity: Float
}

"""
order by var_pop() on columns of table "dishes"
"""
input dishes_var_pop_order_by {
  carbs: order_by
  fat: order_by
  protein: order_by
  quantity: order_by
}

"""aggregate var_samp on columns"""
type dishes_var_samp_fields {
  carbs: Float
  fat: Float
  protein: Float
  quantity: Float
}

"""
order by var_samp() on columns of table "dishes"
"""
input dishes_var_samp_order_by {
  carbs: order_by
  fat: order_by
  protein: order_by
  quantity: order_by
}

"""aggregate variance on columns"""
type dishes_variance_fields {
  carbs: Float
  fat: Float
  protein: Float
  quantity: Float
}

"""
order by variance() on columns of table "dishes"
"""
input dishes_variance_order_by {
  carbs: order_by
  fat: order_by
  protein: order_by
  quantity: order_by
}

scalar float8

"""
expression to compare columns of type float8. All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

"""
columns and relationships of "food"
"""
type food {
  created_at: timestamptz!
  dish_id: uuid!
  id: uuid!

  """An object relationship"""
  ref_dish: dishes!
  timestamp: timestamptz!
  updated_at: timestamptz!
  user_id: String!
}

"""
aggregated selection of "food"
"""
type food_aggregate {
  aggregate: food_aggregate_fields
  nodes: [food!]!
}

"""
aggregate fields of "food"
"""
type food_aggregate_fields {
  count(columns: [food_select_column!], distinct: Boolean): Int
  max: food_max_fields
  min: food_min_fields
}

"""
order by aggregate values of table "food"
"""
input food_aggregate_order_by {
  count: order_by
  max: food_max_order_by
  min: food_min_order_by
}

"""
input type for inserting array relation for remote table "food"
"""
input food_arr_rel_insert_input {
  data: [food_insert_input!]!
  on_conflict: food_on_conflict
}

"""
Boolean expression to filter rows from the table "food". All fields are combined with a logical 'AND'.
"""
input food_bool_exp {
  _and: [food_bool_exp]
  _not: food_bool_exp
  _or: [food_bool_exp]
  created_at: timestamptz_comparison_exp
  dish_id: uuid_comparison_exp
  id: uuid_comparison_exp
  ref_dish: dishes_bool_exp
  timestamp: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "food"
"""
enum food_constraint {
  """unique or primary key constraint"""
  food_pkey
}

"""
input type for inserting data into table "food"
"""
input food_insert_input {
  created_at: timestamptz
  dish_id: uuid
  id: uuid
  ref_dish: dishes_obj_rel_insert_input
  timestamp: timestamptz
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type food_max_fields {
  created_at: timestamptz
  dish_id: uuid
  id: uuid
  timestamp: timestamptz
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "food"
"""
input food_max_order_by {
  created_at: order_by
  dish_id: order_by
  id: order_by
  timestamp: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type food_min_fields {
  created_at: timestamptz
  dish_id: uuid
  id: uuid
  timestamp: timestamptz
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "food"
"""
input food_min_order_by {
  created_at: order_by
  dish_id: order_by
  id: order_by
  timestamp: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "food"
"""
type food_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [food!]!
}

"""
input type for inserting object relation for remote table "food"
"""
input food_obj_rel_insert_input {
  data: food_insert_input!
  on_conflict: food_on_conflict
}

"""
on conflict condition type for table "food"
"""
input food_on_conflict {
  constraint: food_constraint!
  update_columns: [food_update_column!]!
  where: food_bool_exp
}

"""
ordering options when selecting data from "food"
"""
input food_order_by {
  created_at: order_by
  dish_id: order_by
  id: order_by
  ref_dish: dishes_order_by
  timestamp: order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "food"
"""
input food_pk_columns_input {
  id: uuid!
}

"""
select columns of table "food"
"""
enum food_select_column {
  """column name"""
  created_at

  """column name"""
  dish_id

  """column name"""
  id

  """column name"""
  timestamp

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "food"
"""
input food_set_input {
  created_at: timestamptz
  dish_id: uuid
  id: uuid
  timestamp: timestamptz
  updated_at: timestamptz
  user_id: String
}

"""
update columns of table "food"
"""
enum food_update_column {
  """column name"""
  created_at

  """column name"""
  dish_id

  """column name"""
  id

  """column name"""
  timestamp

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
columns and relationships of "glucose"
"""
type glucose {
  created_at: timestamptz!
  description: String
  id: uuid!
  timestamp: timestamptz!
  updated_at: timestamptz!
  user_id: String
  value: Int!
}

"""
aggregated selection of "glucose"
"""
type glucose_aggregate {
  aggregate: glucose_aggregate_fields
  nodes: [glucose!]!
}

"""
aggregate fields of "glucose"
"""
type glucose_aggregate_fields {
  avg: glucose_avg_fields
  count(columns: [glucose_select_column!], distinct: Boolean): Int
  max: glucose_max_fields
  min: glucose_min_fields
  stddev: glucose_stddev_fields
  stddev_pop: glucose_stddev_pop_fields
  stddev_samp: glucose_stddev_samp_fields
  sum: glucose_sum_fields
  var_pop: glucose_var_pop_fields
  var_samp: glucose_var_samp_fields
  variance: glucose_variance_fields
}

"""
order by aggregate values of table "glucose"
"""
input glucose_aggregate_order_by {
  avg: glucose_avg_order_by
  count: order_by
  max: glucose_max_order_by
  min: glucose_min_order_by
  stddev: glucose_stddev_order_by
  stddev_pop: glucose_stddev_pop_order_by
  stddev_samp: glucose_stddev_samp_order_by
  sum: glucose_sum_order_by
  var_pop: glucose_var_pop_order_by
  var_samp: glucose_var_samp_order_by
  variance: glucose_variance_order_by
}

"""
input type for inserting array relation for remote table "glucose"
"""
input glucose_arr_rel_insert_input {
  data: [glucose_insert_input!]!
  on_conflict: glucose_on_conflict
}

"""aggregate avg on columns"""
type glucose_avg_fields {
  value: Float
}

"""
order by avg() on columns of table "glucose"
"""
input glucose_avg_order_by {
  value: order_by
}

"""
Boolean expression to filter rows from the table "glucose". All fields are combined with a logical 'AND'.
"""
input glucose_bool_exp {
  _and: [glucose_bool_exp]
  _not: glucose_bool_exp
  _or: [glucose_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  timestamp: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
  value: Int_comparison_exp
}

"""
unique or primary key constraints on table "glucose"
"""
enum glucose_constraint {
  """unique or primary key constraint"""
  glucose_pkey
}

"""
input type for incrementing integer column in table "glucose"
"""
input glucose_inc_input {
  value: Int
}

"""
input type for inserting data into table "glucose"
"""
input glucose_insert_input {
  created_at: timestamptz
  description: String
  id: uuid
  timestamp: timestamptz
  updated_at: timestamptz
  user_id: String
  value: Int
}

"""aggregate max on columns"""
type glucose_max_fields {
  created_at: timestamptz
  description: String
  id: uuid
  timestamp: timestamptz
  updated_at: timestamptz
  user_id: String
  value: Int
}

"""
order by max() on columns of table "glucose"
"""
input glucose_max_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  timestamp: order_by
  updated_at: order_by
  user_id: order_by
  value: order_by
}

"""aggregate min on columns"""
type glucose_min_fields {
  created_at: timestamptz
  description: String
  id: uuid
  timestamp: timestamptz
  updated_at: timestamptz
  user_id: String
  value: Int
}

"""
order by min() on columns of table "glucose"
"""
input glucose_min_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  timestamp: order_by
  updated_at: order_by
  user_id: order_by
  value: order_by
}

"""
response of any mutation on the table "glucose"
"""
type glucose_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [glucose!]!
}

"""
input type for inserting object relation for remote table "glucose"
"""
input glucose_obj_rel_insert_input {
  data: glucose_insert_input!
  on_conflict: glucose_on_conflict
}

"""
on conflict condition type for table "glucose"
"""
input glucose_on_conflict {
  constraint: glucose_constraint!
  update_columns: [glucose_update_column!]!
  where: glucose_bool_exp
}

"""
ordering options when selecting data from "glucose"
"""
input glucose_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  timestamp: order_by
  updated_at: order_by
  user_id: order_by
  value: order_by
}

"""
primary key columns input for table: "glucose"
"""
input glucose_pk_columns_input {
  id: uuid!
}

"""
select columns of table "glucose"
"""
enum glucose_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  timestamp

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  value
}

"""
input type for updating data in table "glucose"
"""
input glucose_set_input {
  created_at: timestamptz
  description: String
  id: uuid
  timestamp: timestamptz
  updated_at: timestamptz
  user_id: String
  value: Int
}

"""aggregate stddev on columns"""
type glucose_stddev_fields {
  value: Float
}

"""
order by stddev() on columns of table "glucose"
"""
input glucose_stddev_order_by {
  value: order_by
}

"""aggregate stddev_pop on columns"""
type glucose_stddev_pop_fields {
  value: Float
}

"""
order by stddev_pop() on columns of table "glucose"
"""
input glucose_stddev_pop_order_by {
  value: order_by
}

"""aggregate stddev_samp on columns"""
type glucose_stddev_samp_fields {
  value: Float
}

"""
order by stddev_samp() on columns of table "glucose"
"""
input glucose_stddev_samp_order_by {
  value: order_by
}

"""aggregate sum on columns"""
type glucose_sum_fields {
  value: Int
}

"""
order by sum() on columns of table "glucose"
"""
input glucose_sum_order_by {
  value: order_by
}

"""
update columns of table "glucose"
"""
enum glucose_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  timestamp

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  value
}

"""aggregate var_pop on columns"""
type glucose_var_pop_fields {
  value: Float
}

"""
order by var_pop() on columns of table "glucose"
"""
input glucose_var_pop_order_by {
  value: order_by
}

"""aggregate var_samp on columns"""
type glucose_var_samp_fields {
  value: Float
}

"""
order by var_samp() on columns of table "glucose"
"""
input glucose_var_samp_order_by {
  value: order_by
}

"""aggregate variance on columns"""
type glucose_variance_fields {
  value: Float
}

"""
order by variance() on columns of table "glucose"
"""
input glucose_variance_order_by {
  value: order_by
}

"""
columns and relationships of "inbox"
"""
type inbox {
  created_at: timestamptz!
  description: String
  id: Int!
  name: String!
  updated_at: timestamptz!
  user_id: String
}

"""
aggregated selection of "inbox"
"""
type inbox_aggregate {
  aggregate: inbox_aggregate_fields
  nodes: [inbox!]!
}

"""
aggregate fields of "inbox"
"""
type inbox_aggregate_fields {
  avg: inbox_avg_fields
  count(columns: [inbox_select_column!], distinct: Boolean): Int
  max: inbox_max_fields
  min: inbox_min_fields
  stddev: inbox_stddev_fields
  stddev_pop: inbox_stddev_pop_fields
  stddev_samp: inbox_stddev_samp_fields
  sum: inbox_sum_fields
  var_pop: inbox_var_pop_fields
  var_samp: inbox_var_samp_fields
  variance: inbox_variance_fields
}

"""
order by aggregate values of table "inbox"
"""
input inbox_aggregate_order_by {
  avg: inbox_avg_order_by
  count: order_by
  max: inbox_max_order_by
  min: inbox_min_order_by
  stddev: inbox_stddev_order_by
  stddev_pop: inbox_stddev_pop_order_by
  stddev_samp: inbox_stddev_samp_order_by
  sum: inbox_sum_order_by
  var_pop: inbox_var_pop_order_by
  var_samp: inbox_var_samp_order_by
  variance: inbox_variance_order_by
}

"""
input type for inserting array relation for remote table "inbox"
"""
input inbox_arr_rel_insert_input {
  data: [inbox_insert_input!]!
  on_conflict: inbox_on_conflict
}

"""aggregate avg on columns"""
type inbox_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "inbox"
"""
input inbox_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "inbox". All fields are combined with a logical 'AND'.
"""
input inbox_bool_exp {
  _and: [inbox_bool_exp]
  _not: inbox_bool_exp
  _or: [inbox_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "inbox"
"""
enum inbox_constraint {
  """unique or primary key constraint"""
  inbox_pkey
}

"""
input type for incrementing integer column in table "inbox"
"""
input inbox_inc_input {
  id: Int
}

"""
input type for inserting data into table "inbox"
"""
input inbox_insert_input {
  created_at: timestamptz
  description: String
  id: Int
  name: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type inbox_max_fields {
  created_at: timestamptz
  description: String
  id: Int
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "inbox"
"""
input inbox_max_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type inbox_min_fields {
  created_at: timestamptz
  description: String
  id: Int
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "inbox"
"""
input inbox_min_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "inbox"
"""
type inbox_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [inbox!]!
}

"""
input type for inserting object relation for remote table "inbox"
"""
input inbox_obj_rel_insert_input {
  data: inbox_insert_input!
  on_conflict: inbox_on_conflict
}

"""
on conflict condition type for table "inbox"
"""
input inbox_on_conflict {
  constraint: inbox_constraint!
  update_columns: [inbox_update_column!]!
  where: inbox_bool_exp
}

"""
ordering options when selecting data from "inbox"
"""
input inbox_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "inbox"
"""
input inbox_pk_columns_input {
  id: Int!
}

"""
select columns of table "inbox"
"""
enum inbox_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "inbox"
"""
input inbox_set_input {
  created_at: timestamptz
  description: String
  id: Int
  name: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type inbox_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "inbox"
"""
input inbox_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type inbox_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "inbox"
"""
input inbox_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type inbox_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "inbox"
"""
input inbox_stddev_samp_order_by {
  id: order_by
}

"""aggregate sum on columns"""
type inbox_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "inbox"
"""
input inbox_sum_order_by {
  id: order_by
}

"""
update columns of table "inbox"
"""
enum inbox_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type inbox_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "inbox"
"""
input inbox_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type inbox_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "inbox"
"""
input inbox_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type inbox_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "inbox"
"""
input inbox_variance_order_by {
  id: order_by
}

"""
expression to compare columns of type Int. All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar jsonb

"""
expression to compare columns of type jsonb. All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "key_results"
"""
type key_results {
  created_at: timestamptz!
  description: String
  id: uuid!
  name: String!
  objective_id: uuid!
  progress: float8!

  """An object relationship"""
  ref_objective: objectives!
  updated_at: timestamptz!
  user_id: String!
}

"""
aggregated selection of "key_results"
"""
type key_results_aggregate {
  aggregate: key_results_aggregate_fields
  nodes: [key_results!]!
}

"""
aggregate fields of "key_results"
"""
type key_results_aggregate_fields {
  avg: key_results_avg_fields
  count(columns: [key_results_select_column!], distinct: Boolean): Int
  max: key_results_max_fields
  min: key_results_min_fields
  stddev: key_results_stddev_fields
  stddev_pop: key_results_stddev_pop_fields
  stddev_samp: key_results_stddev_samp_fields
  sum: key_results_sum_fields
  var_pop: key_results_var_pop_fields
  var_samp: key_results_var_samp_fields
  variance: key_results_variance_fields
}

"""
order by aggregate values of table "key_results"
"""
input key_results_aggregate_order_by {
  avg: key_results_avg_order_by
  count: order_by
  max: key_results_max_order_by
  min: key_results_min_order_by
  stddev: key_results_stddev_order_by
  stddev_pop: key_results_stddev_pop_order_by
  stddev_samp: key_results_stddev_samp_order_by
  sum: key_results_sum_order_by
  var_pop: key_results_var_pop_order_by
  var_samp: key_results_var_samp_order_by
  variance: key_results_variance_order_by
}

"""
input type for inserting array relation for remote table "key_results"
"""
input key_results_arr_rel_insert_input {
  data: [key_results_insert_input!]!
  on_conflict: key_results_on_conflict
}

"""aggregate avg on columns"""
type key_results_avg_fields {
  progress: Float
}

"""
order by avg() on columns of table "key_results"
"""
input key_results_avg_order_by {
  progress: order_by
}

"""
Boolean expression to filter rows from the table "key_results". All fields are combined with a logical 'AND'.
"""
input key_results_bool_exp {
  _and: [key_results_bool_exp]
  _not: key_results_bool_exp
  _or: [key_results_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  objective_id: uuid_comparison_exp
  progress: float8_comparison_exp
  ref_objective: objectives_bool_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "key_results"
"""
enum key_results_constraint {
  """unique or primary key constraint"""
  key_results_pkey
}

"""
input type for incrementing integer column in table "key_results"
"""
input key_results_inc_input {
  progress: float8
}

"""
input type for inserting data into table "key_results"
"""
input key_results_insert_input {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  objective_id: uuid
  progress: float8
  ref_objective: objectives_obj_rel_insert_input
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type key_results_max_fields {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  objective_id: uuid
  progress: float8
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "key_results"
"""
input key_results_max_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  objective_id: order_by
  progress: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type key_results_min_fields {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  objective_id: uuid
  progress: float8
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "key_results"
"""
input key_results_min_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  objective_id: order_by
  progress: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "key_results"
"""
type key_results_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [key_results!]!
}

"""
input type for inserting object relation for remote table "key_results"
"""
input key_results_obj_rel_insert_input {
  data: key_results_insert_input!
  on_conflict: key_results_on_conflict
}

"""
on conflict condition type for table "key_results"
"""
input key_results_on_conflict {
  constraint: key_results_constraint!
  update_columns: [key_results_update_column!]!
  where: key_results_bool_exp
}

"""
ordering options when selecting data from "key_results"
"""
input key_results_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  objective_id: order_by
  progress: order_by
  ref_objective: objectives_order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "key_results"
"""
input key_results_pk_columns_input {
  id: uuid!
}

"""
select columns of table "key_results"
"""
enum key_results_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  objective_id

  """column name"""
  progress

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "key_results"
"""
input key_results_set_input {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  objective_id: uuid
  progress: float8
  updated_at: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type key_results_stddev_fields {
  progress: Float
}

"""
order by stddev() on columns of table "key_results"
"""
input key_results_stddev_order_by {
  progress: order_by
}

"""aggregate stddev_pop on columns"""
type key_results_stddev_pop_fields {
  progress: Float
}

"""
order by stddev_pop() on columns of table "key_results"
"""
input key_results_stddev_pop_order_by {
  progress: order_by
}

"""aggregate stddev_samp on columns"""
type key_results_stddev_samp_fields {
  progress: Float
}

"""
order by stddev_samp() on columns of table "key_results"
"""
input key_results_stddev_samp_order_by {
  progress: order_by
}

"""aggregate sum on columns"""
type key_results_sum_fields {
  progress: float8
}

"""
order by sum() on columns of table "key_results"
"""
input key_results_sum_order_by {
  progress: order_by
}

"""
update columns of table "key_results"
"""
enum key_results_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  objective_id

  """column name"""
  progress

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type key_results_var_pop_fields {
  progress: Float
}

"""
order by var_pop() on columns of table "key_results"
"""
input key_results_var_pop_order_by {
  progress: order_by
}

"""aggregate var_samp on columns"""
type key_results_var_samp_fields {
  progress: Float
}

"""
order by var_samp() on columns of table "key_results"
"""
input key_results_var_samp_order_by {
  progress: order_by
}

"""aggregate variance on columns"""
type key_results_variance_fields {
  progress: Float
}

"""
order by variance() on columns of table "key_results"
"""
input key_results_variance_order_by {
  progress: order_by
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "categories"
  """
  delete_categories(
    """filter the rows which have to be deleted"""
    where: categories_bool_exp!
  ): categories_mutation_response

  """
  delete single row from the table: "categories"
  """
  delete_categories_by_pk(id: uuid!): categories

  """
  delete data from the table: "dishes"
  """
  delete_dishes(
    """filter the rows which have to be deleted"""
    where: dishes_bool_exp!
  ): dishes_mutation_response

  """
  delete single row from the table: "dishes"
  """
  delete_dishes_by_pk(id: uuid!): dishes

  """
  delete data from the table: "food"
  """
  delete_food(
    """filter the rows which have to be deleted"""
    where: food_bool_exp!
  ): food_mutation_response

  """
  delete single row from the table: "food"
  """
  delete_food_by_pk(id: uuid!): food

  """
  delete data from the table: "glucose"
  """
  delete_glucose(
    """filter the rows which have to be deleted"""
    where: glucose_bool_exp!
  ): glucose_mutation_response

  """
  delete single row from the table: "glucose"
  """
  delete_glucose_by_pk(id: uuid!): glucose

  """
  delete data from the table: "inbox"
  """
  delete_inbox(
    """filter the rows which have to be deleted"""
    where: inbox_bool_exp!
  ): inbox_mutation_response

  """
  delete single row from the table: "inbox"
  """
  delete_inbox_by_pk(id: Int!): inbox

  """
  delete data from the table: "key_results"
  """
  delete_key_results(
    """filter the rows which have to be deleted"""
    where: key_results_bool_exp!
  ): key_results_mutation_response

  """
  delete single row from the table: "key_results"
  """
  delete_key_results_by_pk(id: uuid!): key_results

  """
  delete data from the table: "notes"
  """
  delete_notes(
    """filter the rows which have to be deleted"""
    where: notes_bool_exp!
  ): notes_mutation_response

  """
  delete single row from the table: "notes"
  """
  delete_notes_by_pk(id: uuid!): notes

  """
  delete data from the table: "notes_snippets"
  """
  delete_notes_snippets(
    """filter the rows which have to be deleted"""
    where: notes_snippets_bool_exp!
  ): notes_snippets_mutation_response

  """
  delete single row from the table: "notes_snippets"
  """
  delete_notes_snippets_by_pk(note_id: uuid!, snippet_id: uuid!): notes_snippets

  """
  delete data from the table: "objective_team"
  """
  delete_objective_team(
    """filter the rows which have to be deleted"""
    where: objective_team_bool_exp!
  ): objective_team_mutation_response

  """
  delete single row from the table: "objective_team"
  """
  delete_objective_team_by_pk(objective_id: uuid!, team_id: uuid!): objective_team

  """
  delete data from the table: "objectives"
  """
  delete_objectives(
    """filter the rows which have to be deleted"""
    where: objectives_bool_exp!
  ): objectives_mutation_response

  """
  delete single row from the table: "objectives"
  """
  delete_objectives_by_pk(id: uuid!): objectives

  """
  delete data from the table: "people"
  """
  delete_people(
    """filter the rows which have to be deleted"""
    where: people_bool_exp!
  ): people_mutation_response

  """
  delete single row from the table: "people"
  """
  delete_people_by_pk(id: uuid!): people

  """
  delete data from the table: "projects"
  """
  delete_projects(
    """filter the rows which have to be deleted"""
    where: projects_bool_exp!
  ): projects_mutation_response

  """
  delete single row from the table: "projects"
  """
  delete_projects_by_pk(id: uuid!): projects

  """
  delete data from the table: "reviews"
  """
  delete_reviews(
    """filter the rows which have to be deleted"""
    where: reviews_bool_exp!
  ): reviews_mutation_response

  """
  delete single row from the table: "reviews"
  """
  delete_reviews_by_pk(id: uuid!): reviews

  """
  delete data from the table: "snippets"
  """
  delete_snippets(
    """filter the rows which have to be deleted"""
    where: snippets_bool_exp!
  ): snippets_mutation_response

  """
  delete single row from the table: "snippets"
  """
  delete_snippets_by_pk(id: uuid!): snippets

  """
  delete data from the table: "snippets_mapping"
  """
  delete_snippets_mapping(
    """filter the rows which have to be deleted"""
    where: snippets_mapping_bool_exp!
  ): snippets_mapping_mutation_response

  """
  delete single row from the table: "snippets_mapping"
  """
  delete_snippets_mapping_by_pk(source_id: uuid!, target_id: uuid!): snippets_mapping

  """
  delete data from the table: "tasks"
  """
  delete_tasks(
    """filter the rows which have to be deleted"""
    where: tasks_bool_exp!
  ): tasks_mutation_response

  """
  delete single row from the table: "tasks"
  """
  delete_tasks_by_pk(id: uuid!): tasks

  """
  delete data from the table: "teams"
  """
  delete_teams(
    """filter the rows which have to be deleted"""
    where: teams_bool_exp!
  ): teams_mutation_response

  """
  delete single row from the table: "teams"
  """
  delete_teams_by_pk(id: uuid!): teams

  """
  delete data from the table: "thoughts"
  """
  delete_thoughts(
    """filter the rows which have to be deleted"""
    where: thoughts_bool_exp!
  ): thoughts_mutation_response

  """
  delete single row from the table: "thoughts"
  """
  delete_thoughts_by_pk(id: uuid!): thoughts

  """
  delete data from the table: "transactions"
  """
  delete_transactions(
    """filter the rows which have to be deleted"""
    where: transactions_bool_exp!
  ): transactions_mutation_response

  """
  delete single row from the table: "transactions"
  """
  delete_transactions_by_pk(id: uuid!): transactions

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: String!): users

  """
  delete data from the table: "water"
  """
  delete_water(
    """filter the rows which have to be deleted"""
    where: water_bool_exp!
  ): water_mutation_response

  """
  delete single row from the table: "water"
  """
  delete_water_by_pk(id: uuid!): water

  """
  insert data into the table: "categories"
  """
  insert_categories(
    """the rows to be inserted"""
    objects: [categories_insert_input!]!

    """on conflict condition"""
    on_conflict: categories_on_conflict
  ): categories_mutation_response

  """
  insert a single row into the table: "categories"
  """
  insert_categories_one(
    """the row to be inserted"""
    object: categories_insert_input!

    """on conflict condition"""
    on_conflict: categories_on_conflict
  ): categories

  """
  insert data into the table: "dishes"
  """
  insert_dishes(
    """the rows to be inserted"""
    objects: [dishes_insert_input!]!

    """on conflict condition"""
    on_conflict: dishes_on_conflict
  ): dishes_mutation_response

  """
  insert a single row into the table: "dishes"
  """
  insert_dishes_one(
    """the row to be inserted"""
    object: dishes_insert_input!

    """on conflict condition"""
    on_conflict: dishes_on_conflict
  ): dishes

  """
  insert data into the table: "food"
  """
  insert_food(
    """the rows to be inserted"""
    objects: [food_insert_input!]!

    """on conflict condition"""
    on_conflict: food_on_conflict
  ): food_mutation_response

  """
  insert a single row into the table: "food"
  """
  insert_food_one(
    """the row to be inserted"""
    object: food_insert_input!

    """on conflict condition"""
    on_conflict: food_on_conflict
  ): food

  """
  insert data into the table: "glucose"
  """
  insert_glucose(
    """the rows to be inserted"""
    objects: [glucose_insert_input!]!

    """on conflict condition"""
    on_conflict: glucose_on_conflict
  ): glucose_mutation_response

  """
  insert a single row into the table: "glucose"
  """
  insert_glucose_one(
    """the row to be inserted"""
    object: glucose_insert_input!

    """on conflict condition"""
    on_conflict: glucose_on_conflict
  ): glucose

  """
  insert data into the table: "inbox"
  """
  insert_inbox(
    """the rows to be inserted"""
    objects: [inbox_insert_input!]!

    """on conflict condition"""
    on_conflict: inbox_on_conflict
  ): inbox_mutation_response

  """
  insert a single row into the table: "inbox"
  """
  insert_inbox_one(
    """the row to be inserted"""
    object: inbox_insert_input!

    """on conflict condition"""
    on_conflict: inbox_on_conflict
  ): inbox

  """
  insert data into the table: "key_results"
  """
  insert_key_results(
    """the rows to be inserted"""
    objects: [key_results_insert_input!]!

    """on conflict condition"""
    on_conflict: key_results_on_conflict
  ): key_results_mutation_response

  """
  insert a single row into the table: "key_results"
  """
  insert_key_results_one(
    """the row to be inserted"""
    object: key_results_insert_input!

    """on conflict condition"""
    on_conflict: key_results_on_conflict
  ): key_results

  """
  insert data into the table: "notes"
  """
  insert_notes(
    """the rows to be inserted"""
    objects: [notes_insert_input!]!

    """on conflict condition"""
    on_conflict: notes_on_conflict
  ): notes_mutation_response

  """
  insert a single row into the table: "notes"
  """
  insert_notes_one(
    """the row to be inserted"""
    object: notes_insert_input!

    """on conflict condition"""
    on_conflict: notes_on_conflict
  ): notes

  """
  insert data into the table: "notes_snippets"
  """
  insert_notes_snippets(
    """the rows to be inserted"""
    objects: [notes_snippets_insert_input!]!

    """on conflict condition"""
    on_conflict: notes_snippets_on_conflict
  ): notes_snippets_mutation_response

  """
  insert a single row into the table: "notes_snippets"
  """
  insert_notes_snippets_one(
    """the row to be inserted"""
    object: notes_snippets_insert_input!

    """on conflict condition"""
    on_conflict: notes_snippets_on_conflict
  ): notes_snippets

  """
  insert data into the table: "objective_team"
  """
  insert_objective_team(
    """the rows to be inserted"""
    objects: [objective_team_insert_input!]!

    """on conflict condition"""
    on_conflict: objective_team_on_conflict
  ): objective_team_mutation_response

  """
  insert a single row into the table: "objective_team"
  """
  insert_objective_team_one(
    """the row to be inserted"""
    object: objective_team_insert_input!

    """on conflict condition"""
    on_conflict: objective_team_on_conflict
  ): objective_team

  """
  insert data into the table: "objectives"
  """
  insert_objectives(
    """the rows to be inserted"""
    objects: [objectives_insert_input!]!

    """on conflict condition"""
    on_conflict: objectives_on_conflict
  ): objectives_mutation_response

  """
  insert a single row into the table: "objectives"
  """
  insert_objectives_one(
    """the row to be inserted"""
    object: objectives_insert_input!

    """on conflict condition"""
    on_conflict: objectives_on_conflict
  ): objectives

  """
  insert data into the table: "people"
  """
  insert_people(
    """the rows to be inserted"""
    objects: [people_insert_input!]!

    """on conflict condition"""
    on_conflict: people_on_conflict
  ): people_mutation_response

  """
  insert a single row into the table: "people"
  """
  insert_people_one(
    """the row to be inserted"""
    object: people_insert_input!

    """on conflict condition"""
    on_conflict: people_on_conflict
  ): people

  """
  insert data into the table: "projects"
  """
  insert_projects(
    """the rows to be inserted"""
    objects: [projects_insert_input!]!

    """on conflict condition"""
    on_conflict: projects_on_conflict
  ): projects_mutation_response

  """
  insert a single row into the table: "projects"
  """
  insert_projects_one(
    """the row to be inserted"""
    object: projects_insert_input!

    """on conflict condition"""
    on_conflict: projects_on_conflict
  ): projects

  """
  insert data into the table: "reviews"
  """
  insert_reviews(
    """the rows to be inserted"""
    objects: [reviews_insert_input!]!

    """on conflict condition"""
    on_conflict: reviews_on_conflict
  ): reviews_mutation_response

  """
  insert a single row into the table: "reviews"
  """
  insert_reviews_one(
    """the row to be inserted"""
    object: reviews_insert_input!

    """on conflict condition"""
    on_conflict: reviews_on_conflict
  ): reviews

  """
  insert data into the table: "snippets"
  """
  insert_snippets(
    """the rows to be inserted"""
    objects: [snippets_insert_input!]!

    """on conflict condition"""
    on_conflict: snippets_on_conflict
  ): snippets_mutation_response

  """
  insert data into the table: "snippets_mapping"
  """
  insert_snippets_mapping(
    """the rows to be inserted"""
    objects: [snippets_mapping_insert_input!]!

    """on conflict condition"""
    on_conflict: snippets_mapping_on_conflict
  ): snippets_mapping_mutation_response

  """
  insert a single row into the table: "snippets_mapping"
  """
  insert_snippets_mapping_one(
    """the row to be inserted"""
    object: snippets_mapping_insert_input!

    """on conflict condition"""
    on_conflict: snippets_mapping_on_conflict
  ): snippets_mapping

  """
  insert a single row into the table: "snippets"
  """
  insert_snippets_one(
    """the row to be inserted"""
    object: snippets_insert_input!

    """on conflict condition"""
    on_conflict: snippets_on_conflict
  ): snippets

  """
  insert data into the table: "tasks"
  """
  insert_tasks(
    """the rows to be inserted"""
    objects: [tasks_insert_input!]!

    """on conflict condition"""
    on_conflict: tasks_on_conflict
  ): tasks_mutation_response

  """
  insert a single row into the table: "tasks"
  """
  insert_tasks_one(
    """the row to be inserted"""
    object: tasks_insert_input!

    """on conflict condition"""
    on_conflict: tasks_on_conflict
  ): tasks

  """
  insert data into the table: "teams"
  """
  insert_teams(
    """the rows to be inserted"""
    objects: [teams_insert_input!]!

    """on conflict condition"""
    on_conflict: teams_on_conflict
  ): teams_mutation_response

  """
  insert a single row into the table: "teams"
  """
  insert_teams_one(
    """the row to be inserted"""
    object: teams_insert_input!

    """on conflict condition"""
    on_conflict: teams_on_conflict
  ): teams

  """
  insert data into the table: "thoughts"
  """
  insert_thoughts(
    """the rows to be inserted"""
    objects: [thoughts_insert_input!]!

    """on conflict condition"""
    on_conflict: thoughts_on_conflict
  ): thoughts_mutation_response

  """
  insert a single row into the table: "thoughts"
  """
  insert_thoughts_one(
    """the row to be inserted"""
    object: thoughts_insert_input!

    """on conflict condition"""
    on_conflict: thoughts_on_conflict
  ): thoughts

  """
  insert data into the table: "transactions"
  """
  insert_transactions(
    """the rows to be inserted"""
    objects: [transactions_insert_input!]!

    """on conflict condition"""
    on_conflict: transactions_on_conflict
  ): transactions_mutation_response

  """
  insert a single row into the table: "transactions"
  """
  insert_transactions_one(
    """the row to be inserted"""
    object: transactions_insert_input!

    """on conflict condition"""
    on_conflict: transactions_on_conflict
  ): transactions

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "water"
  """
  insert_water(
    """the rows to be inserted"""
    objects: [water_insert_input!]!

    """on conflict condition"""
    on_conflict: water_on_conflict
  ): water_mutation_response

  """
  insert a single row into the table: "water"
  """
  insert_water_one(
    """the row to be inserted"""
    object: water_insert_input!

    """on conflict condition"""
    on_conflict: water_on_conflict
  ): water

  """
  update data of the table: "categories"
  """
  update_categories(
    """sets the columns of the filtered rows to the given values"""
    _set: categories_set_input

    """filter the rows which have to be updated"""
    where: categories_bool_exp!
  ): categories_mutation_response

  """
  update single row of the table: "categories"
  """
  update_categories_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: categories_set_input
    pk_columns: categories_pk_columns_input!
  ): categories

  """
  update data of the table: "dishes"
  """
  update_dishes(
    """increments the integer columns with given value of the filtered values"""
    _inc: dishes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: dishes_set_input

    """filter the rows which have to be updated"""
    where: dishes_bool_exp!
  ): dishes_mutation_response

  """
  update single row of the table: "dishes"
  """
  update_dishes_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: dishes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: dishes_set_input
    pk_columns: dishes_pk_columns_input!
  ): dishes

  """
  update data of the table: "food"
  """
  update_food(
    """sets the columns of the filtered rows to the given values"""
    _set: food_set_input

    """filter the rows which have to be updated"""
    where: food_bool_exp!
  ): food_mutation_response

  """
  update single row of the table: "food"
  """
  update_food_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: food_set_input
    pk_columns: food_pk_columns_input!
  ): food

  """
  update data of the table: "glucose"
  """
  update_glucose(
    """increments the integer columns with given value of the filtered values"""
    _inc: glucose_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: glucose_set_input

    """filter the rows which have to be updated"""
    where: glucose_bool_exp!
  ): glucose_mutation_response

  """
  update single row of the table: "glucose"
  """
  update_glucose_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: glucose_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: glucose_set_input
    pk_columns: glucose_pk_columns_input!
  ): glucose

  """
  update data of the table: "inbox"
  """
  update_inbox(
    """increments the integer columns with given value of the filtered values"""
    _inc: inbox_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: inbox_set_input

    """filter the rows which have to be updated"""
    where: inbox_bool_exp!
  ): inbox_mutation_response

  """
  update single row of the table: "inbox"
  """
  update_inbox_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: inbox_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: inbox_set_input
    pk_columns: inbox_pk_columns_input!
  ): inbox

  """
  update data of the table: "key_results"
  """
  update_key_results(
    """increments the integer columns with given value of the filtered values"""
    _inc: key_results_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: key_results_set_input

    """filter the rows which have to be updated"""
    where: key_results_bool_exp!
  ): key_results_mutation_response

  """
  update single row of the table: "key_results"
  """
  update_key_results_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: key_results_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: key_results_set_input
    pk_columns: key_results_pk_columns_input!
  ): key_results

  """
  update data of the table: "notes"
  """
  update_notes(
    """sets the columns of the filtered rows to the given values"""
    _set: notes_set_input

    """filter the rows which have to be updated"""
    where: notes_bool_exp!
  ): notes_mutation_response

  """
  update single row of the table: "notes"
  """
  update_notes_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notes_set_input
    pk_columns: notes_pk_columns_input!
  ): notes

  """
  update data of the table: "notes_snippets"
  """
  update_notes_snippets(
    """sets the columns of the filtered rows to the given values"""
    _set: notes_snippets_set_input

    """filter the rows which have to be updated"""
    where: notes_snippets_bool_exp!
  ): notes_snippets_mutation_response

  """
  update single row of the table: "notes_snippets"
  """
  update_notes_snippets_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notes_snippets_set_input
    pk_columns: notes_snippets_pk_columns_input!
  ): notes_snippets

  """
  update data of the table: "objective_team"
  """
  update_objective_team(
    """sets the columns of the filtered rows to the given values"""
    _set: objective_team_set_input

    """filter the rows which have to be updated"""
    where: objective_team_bool_exp!
  ): objective_team_mutation_response

  """
  update single row of the table: "objective_team"
  """
  update_objective_team_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: objective_team_set_input
    pk_columns: objective_team_pk_columns_input!
  ): objective_team

  """
  update data of the table: "objectives"
  """
  update_objectives(
    """sets the columns of the filtered rows to the given values"""
    _set: objectives_set_input

    """filter the rows which have to be updated"""
    where: objectives_bool_exp!
  ): objectives_mutation_response

  """
  update single row of the table: "objectives"
  """
  update_objectives_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: objectives_set_input
    pk_columns: objectives_pk_columns_input!
  ): objectives

  """
  update data of the table: "people"
  """
  update_people(
    """sets the columns of the filtered rows to the given values"""
    _set: people_set_input

    """filter the rows which have to be updated"""
    where: people_bool_exp!
  ): people_mutation_response

  """
  update single row of the table: "people"
  """
  update_people_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: people_set_input
    pk_columns: people_pk_columns_input!
  ): people

  """
  update data of the table: "projects"
  """
  update_projects(
    """sets the columns of the filtered rows to the given values"""
    _set: projects_set_input

    """filter the rows which have to be updated"""
    where: projects_bool_exp!
  ): projects_mutation_response

  """
  update single row of the table: "projects"
  """
  update_projects_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: projects_set_input
    pk_columns: projects_pk_columns_input!
  ): projects

  """
  update data of the table: "reviews"
  """
  update_reviews(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: reviews_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: reviews_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: reviews_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: reviews_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: reviews_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: reviews_set_input

    """filter the rows which have to be updated"""
    where: reviews_bool_exp!
  ): reviews_mutation_response

  """
  update single row of the table: "reviews"
  """
  update_reviews_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: reviews_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: reviews_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: reviews_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: reviews_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: reviews_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: reviews_set_input
    pk_columns: reviews_pk_columns_input!
  ): reviews

  """
  update data of the table: "snippets"
  """
  update_snippets(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: snippets_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: snippets_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: snippets_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: snippets_delete_key_input

    """increments the integer columns with given value of the filtered values"""
    _inc: snippets_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: snippets_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: snippets_set_input

    """filter the rows which have to be updated"""
    where: snippets_bool_exp!
  ): snippets_mutation_response

  """
  update single row of the table: "snippets"
  """
  update_snippets_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: snippets_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: snippets_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: snippets_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: snippets_delete_key_input

    """increments the integer columns with given value of the filtered values"""
    _inc: snippets_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: snippets_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: snippets_set_input
    pk_columns: snippets_pk_columns_input!
  ): snippets

  """
  update data of the table: "snippets_mapping"
  """
  update_snippets_mapping(
    """sets the columns of the filtered rows to the given values"""
    _set: snippets_mapping_set_input

    """filter the rows which have to be updated"""
    where: snippets_mapping_bool_exp!
  ): snippets_mapping_mutation_response

  """
  update single row of the table: "snippets_mapping"
  """
  update_snippets_mapping_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: snippets_mapping_set_input
    pk_columns: snippets_mapping_pk_columns_input!
  ): snippets_mapping

  """
  update data of the table: "tasks"
  """
  update_tasks(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tasks_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tasks_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: tasks_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tasks_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tasks_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: tasks_set_input

    """filter the rows which have to be updated"""
    where: tasks_bool_exp!
  ): tasks_mutation_response

  """
  update single row of the table: "tasks"
  """
  update_tasks_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: tasks_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: tasks_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: tasks_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: tasks_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: tasks_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: tasks_set_input
    pk_columns: tasks_pk_columns_input!
  ): tasks

  """
  update data of the table: "teams"
  """
  update_teams(
    """sets the columns of the filtered rows to the given values"""
    _set: teams_set_input

    """filter the rows which have to be updated"""
    where: teams_bool_exp!
  ): teams_mutation_response

  """
  update single row of the table: "teams"
  """
  update_teams_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: teams_set_input
    pk_columns: teams_pk_columns_input!
  ): teams

  """
  update data of the table: "thoughts"
  """
  update_thoughts(
    """sets the columns of the filtered rows to the given values"""
    _set: thoughts_set_input

    """filter the rows which have to be updated"""
    where: thoughts_bool_exp!
  ): thoughts_mutation_response

  """
  update single row of the table: "thoughts"
  """
  update_thoughts_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: thoughts_set_input
    pk_columns: thoughts_pk_columns_input!
  ): thoughts

  """
  update data of the table: "transactions"
  """
  update_transactions(
    """increments the integer columns with given value of the filtered values"""
    _inc: transactions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: transactions_set_input

    """filter the rows which have to be updated"""
    where: transactions_bool_exp!
  ): transactions_mutation_response

  """
  update single row of the table: "transactions"
  """
  update_transactions_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: transactions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: transactions_set_input
    pk_columns: transactions_pk_columns_input!
  ): transactions

  """
  update data of the table: "users"
  """
  update_users(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update data of the table: "water"
  """
  update_water(
    """increments the integer columns with given value of the filtered values"""
    _inc: water_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: water_set_input

    """filter the rows which have to be updated"""
    where: water_bool_exp!
  ): water_mutation_response

  """
  update single row of the table: "water"
  """
  update_water_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: water_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: water_set_input
    pk_columns: water_pk_columns_input!
  ): water
}

"""
columns and relationships of "notes"
"""
type notes {
  created_at: timestamptz!
  description: String
  id: uuid!
  name: String!

  """An array relationship"""
  ref_snippets(
    """distinct select on columns"""
    distinct_on: [notes_snippets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_snippets_order_by!]

    """filter the rows returned"""
    where: notes_snippets_bool_exp
  ): [notes_snippets!]!

  """An aggregated array relationship"""
  ref_snippets_aggregate(
    """distinct select on columns"""
    distinct_on: [notes_snippets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_snippets_order_by!]

    """filter the rows returned"""
    where: notes_snippets_bool_exp
  ): notes_snippets_aggregate!
  updated_at: timestamptz!
  user_id: String
}

"""
aggregated selection of "notes"
"""
type notes_aggregate {
  aggregate: notes_aggregate_fields
  nodes: [notes!]!
}

"""
aggregate fields of "notes"
"""
type notes_aggregate_fields {
  count(columns: [notes_select_column!], distinct: Boolean): Int
  max: notes_max_fields
  min: notes_min_fields
}

"""
order by aggregate values of table "notes"
"""
input notes_aggregate_order_by {
  count: order_by
  max: notes_max_order_by
  min: notes_min_order_by
}

"""
input type for inserting array relation for remote table "notes"
"""
input notes_arr_rel_insert_input {
  data: [notes_insert_input!]!
  on_conflict: notes_on_conflict
}

"""
Boolean expression to filter rows from the table "notes". All fields are combined with a logical 'AND'.
"""
input notes_bool_exp {
  _and: [notes_bool_exp]
  _not: notes_bool_exp
  _or: [notes_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  ref_snippets: notes_snippets_bool_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "notes"
"""
enum notes_constraint {
  """unique or primary key constraint"""
  notes_pkey
}

"""
input type for inserting data into table "notes"
"""
input notes_insert_input {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  ref_snippets: notes_snippets_arr_rel_insert_input
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type notes_max_fields {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "notes"
"""
input notes_max_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type notes_min_fields {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "notes"
"""
input notes_min_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "notes"
"""
type notes_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [notes!]!
}

"""
input type for inserting object relation for remote table "notes"
"""
input notes_obj_rel_insert_input {
  data: notes_insert_input!
  on_conflict: notes_on_conflict
}

"""
on conflict condition type for table "notes"
"""
input notes_on_conflict {
  constraint: notes_constraint!
  update_columns: [notes_update_column!]!
  where: notes_bool_exp
}

"""
ordering options when selecting data from "notes"
"""
input notes_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  ref_snippets_aggregate: notes_snippets_aggregate_order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "notes"
"""
input notes_pk_columns_input {
  id: uuid!
}

"""
select columns of table "notes"
"""
enum notes_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "notes"
"""
input notes_set_input {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
columns and relationships of "notes_snippets"
"""
type notes_snippets {
  note_id: uuid!

  """An object relationship"""
  ref_note: notes!

  """An object relationship"""
  ref_snippet: snippets!
  snippet_id: uuid!
  user_id: String
}

"""
aggregated selection of "notes_snippets"
"""
type notes_snippets_aggregate {
  aggregate: notes_snippets_aggregate_fields
  nodes: [notes_snippets!]!
}

"""
aggregate fields of "notes_snippets"
"""
type notes_snippets_aggregate_fields {
  count(columns: [notes_snippets_select_column!], distinct: Boolean): Int
  max: notes_snippets_max_fields
  min: notes_snippets_min_fields
}

"""
order by aggregate values of table "notes_snippets"
"""
input notes_snippets_aggregate_order_by {
  count: order_by
  max: notes_snippets_max_order_by
  min: notes_snippets_min_order_by
}

"""
input type for inserting array relation for remote table "notes_snippets"
"""
input notes_snippets_arr_rel_insert_input {
  data: [notes_snippets_insert_input!]!
  on_conflict: notes_snippets_on_conflict
}

"""
Boolean expression to filter rows from the table "notes_snippets". All fields are combined with a logical 'AND'.
"""
input notes_snippets_bool_exp {
  _and: [notes_snippets_bool_exp]
  _not: notes_snippets_bool_exp
  _or: [notes_snippets_bool_exp]
  note_id: uuid_comparison_exp
  ref_note: notes_bool_exp
  ref_snippet: snippets_bool_exp
  snippet_id: uuid_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "notes_snippets"
"""
enum notes_snippets_constraint {
  """unique or primary key constraint"""
  notes_snippets_pkey
}

"""
input type for inserting data into table "notes_snippets"
"""
input notes_snippets_insert_input {
  note_id: uuid
  ref_note: notes_obj_rel_insert_input
  ref_snippet: snippets_obj_rel_insert_input
  snippet_id: uuid
  user_id: String
}

"""aggregate max on columns"""
type notes_snippets_max_fields {
  note_id: uuid
  snippet_id: uuid
  user_id: String
}

"""
order by max() on columns of table "notes_snippets"
"""
input notes_snippets_max_order_by {
  note_id: order_by
  snippet_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type notes_snippets_min_fields {
  note_id: uuid
  snippet_id: uuid
  user_id: String
}

"""
order by min() on columns of table "notes_snippets"
"""
input notes_snippets_min_order_by {
  note_id: order_by
  snippet_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "notes_snippets"
"""
type notes_snippets_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [notes_snippets!]!
}

"""
input type for inserting object relation for remote table "notes_snippets"
"""
input notes_snippets_obj_rel_insert_input {
  data: notes_snippets_insert_input!
  on_conflict: notes_snippets_on_conflict
}

"""
on conflict condition type for table "notes_snippets"
"""
input notes_snippets_on_conflict {
  constraint: notes_snippets_constraint!
  update_columns: [notes_snippets_update_column!]!
  where: notes_snippets_bool_exp
}

"""
ordering options when selecting data from "notes_snippets"
"""
input notes_snippets_order_by {
  note_id: order_by
  ref_note: notes_order_by
  ref_snippet: snippets_order_by
  snippet_id: order_by
  user_id: order_by
}

"""
primary key columns input for table: "notes_snippets"
"""
input notes_snippets_pk_columns_input {
  note_id: uuid!
  snippet_id: uuid!
}

"""
select columns of table "notes_snippets"
"""
enum notes_snippets_select_column {
  """column name"""
  note_id

  """column name"""
  snippet_id

  """column name"""
  user_id
}

"""
input type for updating data in table "notes_snippets"
"""
input notes_snippets_set_input {
  note_id: uuid
  snippet_id: uuid
  user_id: String
}

"""
update columns of table "notes_snippets"
"""
enum notes_snippets_update_column {
  """column name"""
  note_id

  """column name"""
  snippet_id

  """column name"""
  user_id
}

"""
update columns of table "notes"
"""
enum notes_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  user_id
}

scalar numeric

"""
expression to compare columns of type numeric. All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""
columns and relationships of "objective_team"
"""
type objective_team {
  id: uuid
  objective_id: uuid!

  """An object relationship"""
  ref_objective: objectives!

  """An object relationship"""
  ref_team: teams!
  team_id: uuid!
  user_id: String!
}

"""
aggregated selection of "objective_team"
"""
type objective_team_aggregate {
  aggregate: objective_team_aggregate_fields
  nodes: [objective_team!]!
}

"""
aggregate fields of "objective_team"
"""
type objective_team_aggregate_fields {
  count(columns: [objective_team_select_column!], distinct: Boolean): Int
  max: objective_team_max_fields
  min: objective_team_min_fields
}

"""
order by aggregate values of table "objective_team"
"""
input objective_team_aggregate_order_by {
  count: order_by
  max: objective_team_max_order_by
  min: objective_team_min_order_by
}

"""
input type for inserting array relation for remote table "objective_team"
"""
input objective_team_arr_rel_insert_input {
  data: [objective_team_insert_input!]!
  on_conflict: objective_team_on_conflict
}

"""
Boolean expression to filter rows from the table "objective_team". All fields are combined with a logical 'AND'.
"""
input objective_team_bool_exp {
  _and: [objective_team_bool_exp]
  _not: objective_team_bool_exp
  _or: [objective_team_bool_exp]
  id: uuid_comparison_exp
  objective_id: uuid_comparison_exp
  ref_objective: objectives_bool_exp
  ref_team: teams_bool_exp
  team_id: uuid_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "objective_team"
"""
enum objective_team_constraint {
  """unique or primary key constraint"""
  objective_team_pkey
}

"""
input type for inserting data into table "objective_team"
"""
input objective_team_insert_input {
  id: uuid
  objective_id: uuid
  ref_objective: objectives_obj_rel_insert_input
  ref_team: teams_obj_rel_insert_input
  team_id: uuid
  user_id: String
}

"""aggregate max on columns"""
type objective_team_max_fields {
  id: uuid
  objective_id: uuid
  team_id: uuid
  user_id: String
}

"""
order by max() on columns of table "objective_team"
"""
input objective_team_max_order_by {
  id: order_by
  objective_id: order_by
  team_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type objective_team_min_fields {
  id: uuid
  objective_id: uuid
  team_id: uuid
  user_id: String
}

"""
order by min() on columns of table "objective_team"
"""
input objective_team_min_order_by {
  id: order_by
  objective_id: order_by
  team_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "objective_team"
"""
type objective_team_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [objective_team!]!
}

"""
input type for inserting object relation for remote table "objective_team"
"""
input objective_team_obj_rel_insert_input {
  data: objective_team_insert_input!
  on_conflict: objective_team_on_conflict
}

"""
on conflict condition type for table "objective_team"
"""
input objective_team_on_conflict {
  constraint: objective_team_constraint!
  update_columns: [objective_team_update_column!]!
  where: objective_team_bool_exp
}

"""
ordering options when selecting data from "objective_team"
"""
input objective_team_order_by {
  id: order_by
  objective_id: order_by
  ref_objective: objectives_order_by
  ref_team: teams_order_by
  team_id: order_by
  user_id: order_by
}

"""
primary key columns input for table: "objective_team"
"""
input objective_team_pk_columns_input {
  objective_id: uuid!
  team_id: uuid!
}

"""
select columns of table "objective_team"
"""
enum objective_team_select_column {
  """column name"""
  id

  """column name"""
  objective_id

  """column name"""
  team_id

  """column name"""
  user_id
}

"""
input type for updating data in table "objective_team"
"""
input objective_team_set_input {
  id: uuid
  objective_id: uuid
  team_id: uuid
  user_id: String
}

"""
update columns of table "objective_team"
"""
enum objective_team_update_column {
  """column name"""
  id

  """column name"""
  objective_id

  """column name"""
  team_id

  """column name"""
  user_id
}

"""
columns and relationships of "objectives"
"""
type objectives {
  created_at: timestamptz!
  description: String
  end_date: timestamptz!
  id: uuid!
  key_results: String
  name: String!

  """An array relationship"""
  ref_key_results(
    """distinct select on columns"""
    distinct_on: [key_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [key_results_order_by!]

    """filter the rows returned"""
    where: key_results_bool_exp
  ): [key_results!]!

  """An aggregated array relationship"""
  ref_key_results_aggregate(
    """distinct select on columns"""
    distinct_on: [key_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [key_results_order_by!]

    """filter the rows returned"""
    where: key_results_bool_exp
  ): key_results_aggregate!

  """An array relationship"""
  ref_objective_teams(
    """distinct select on columns"""
    distinct_on: [objective_team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objective_team_order_by!]

    """filter the rows returned"""
    where: objective_team_bool_exp
  ): [objective_team!]!

  """An aggregated array relationship"""
  ref_objective_teams_aggregate(
    """distinct select on columns"""
    distinct_on: [objective_team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objective_team_order_by!]

    """filter the rows returned"""
    where: objective_team_bool_exp
  ): objective_team_aggregate!
  start_date: timestamptz!
  updated_at: timestamptz!
  user_id: String!
}

"""
aggregated selection of "objectives"
"""
type objectives_aggregate {
  aggregate: objectives_aggregate_fields
  nodes: [objectives!]!
}

"""
aggregate fields of "objectives"
"""
type objectives_aggregate_fields {
  count(columns: [objectives_select_column!], distinct: Boolean): Int
  max: objectives_max_fields
  min: objectives_min_fields
}

"""
order by aggregate values of table "objectives"
"""
input objectives_aggregate_order_by {
  count: order_by
  max: objectives_max_order_by
  min: objectives_min_order_by
}

"""
input type for inserting array relation for remote table "objectives"
"""
input objectives_arr_rel_insert_input {
  data: [objectives_insert_input!]!
  on_conflict: objectives_on_conflict
}

"""
Boolean expression to filter rows from the table "objectives". All fields are combined with a logical 'AND'.
"""
input objectives_bool_exp {
  _and: [objectives_bool_exp]
  _not: objectives_bool_exp
  _or: [objectives_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  end_date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  key_results: String_comparison_exp
  name: String_comparison_exp
  ref_key_results: key_results_bool_exp
  ref_objective_teams: objective_team_bool_exp
  start_date: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "objectives"
"""
enum objectives_constraint {
  """unique or primary key constraint"""
  objectives_pkey
}

"""
input type for inserting data into table "objectives"
"""
input objectives_insert_input {
  created_at: timestamptz
  description: String
  end_date: timestamptz
  id: uuid
  key_results: String
  name: String
  ref_key_results: key_results_arr_rel_insert_input
  ref_objective_teams: objective_team_arr_rel_insert_input
  start_date: timestamptz
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type objectives_max_fields {
  created_at: timestamptz
  description: String
  end_date: timestamptz
  id: uuid
  key_results: String
  name: String
  start_date: timestamptz
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "objectives"
"""
input objectives_max_order_by {
  created_at: order_by
  description: order_by
  end_date: order_by
  id: order_by
  key_results: order_by
  name: order_by
  start_date: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type objectives_min_fields {
  created_at: timestamptz
  description: String
  end_date: timestamptz
  id: uuid
  key_results: String
  name: String
  start_date: timestamptz
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "objectives"
"""
input objectives_min_order_by {
  created_at: order_by
  description: order_by
  end_date: order_by
  id: order_by
  key_results: order_by
  name: order_by
  start_date: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "objectives"
"""
type objectives_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [objectives!]!
}

"""
input type for inserting object relation for remote table "objectives"
"""
input objectives_obj_rel_insert_input {
  data: objectives_insert_input!
  on_conflict: objectives_on_conflict
}

"""
on conflict condition type for table "objectives"
"""
input objectives_on_conflict {
  constraint: objectives_constraint!
  update_columns: [objectives_update_column!]!
  where: objectives_bool_exp
}

"""
ordering options when selecting data from "objectives"
"""
input objectives_order_by {
  created_at: order_by
  description: order_by
  end_date: order_by
  id: order_by
  key_results: order_by
  name: order_by
  ref_key_results_aggregate: key_results_aggregate_order_by
  ref_objective_teams_aggregate: objective_team_aggregate_order_by
  start_date: order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "objectives"
"""
input objectives_pk_columns_input {
  id: uuid!
}

"""
select columns of table "objectives"
"""
enum objectives_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  key_results

  """column name"""
  name

  """column name"""
  start_date

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "objectives"
"""
input objectives_set_input {
  created_at: timestamptz
  description: String
  end_date: timestamptz
  id: uuid
  key_results: String
  name: String
  start_date: timestamptz
  updated_at: timestamptz
  user_id: String
}

"""
update columns of table "objectives"
"""
enum objectives_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  key_results

  """column name"""
  name

  """column name"""
  start_date

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""column ordering options"""
enum order_by {
  """in the ascending order, nulls last"""
  asc

  """in the ascending order, nulls first"""
  asc_nulls_first

  """in the ascending order, nulls last"""
  asc_nulls_last

  """in the descending order, nulls first"""
  desc

  """in the descending order, nulls first"""
  desc_nulls_first

  """in the descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "people"
"""
type people {
  created_at: timestamptz!
  id: uuid!
  name: String!
  updated_at: timestamptz!
  user_id: String
}

"""
aggregated selection of "people"
"""
type people_aggregate {
  aggregate: people_aggregate_fields
  nodes: [people!]!
}

"""
aggregate fields of "people"
"""
type people_aggregate_fields {
  count(columns: [people_select_column!], distinct: Boolean): Int
  max: people_max_fields
  min: people_min_fields
}

"""
order by aggregate values of table "people"
"""
input people_aggregate_order_by {
  count: order_by
  max: people_max_order_by
  min: people_min_order_by
}

"""
input type for inserting array relation for remote table "people"
"""
input people_arr_rel_insert_input {
  data: [people_insert_input!]!
  on_conflict: people_on_conflict
}

"""
Boolean expression to filter rows from the table "people". All fields are combined with a logical 'AND'.
"""
input people_bool_exp {
  _and: [people_bool_exp]
  _not: people_bool_exp
  _or: [people_bool_exp]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "people"
"""
enum people_constraint {
  """unique or primary key constraint"""
  people_pkey
}

"""
input type for inserting data into table "people"
"""
input people_insert_input {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type people_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "people"
"""
input people_max_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type people_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "people"
"""
input people_min_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "people"
"""
type people_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [people!]!
}

"""
input type for inserting object relation for remote table "people"
"""
input people_obj_rel_insert_input {
  data: people_insert_input!
  on_conflict: people_on_conflict
}

"""
on conflict condition type for table "people"
"""
input people_on_conflict {
  constraint: people_constraint!
  update_columns: [people_update_column!]!
  where: people_bool_exp
}

"""
ordering options when selecting data from "people"
"""
input people_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "people"
"""
input people_pk_columns_input {
  id: uuid!
}

"""
select columns of table "people"
"""
enum people_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "people"
"""
input people_set_input {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
update columns of table "people"
"""
enum people_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
columns and relationships of "projects"
"""
type projects {
  created_at: timestamptz!
  description: String
  id: uuid!
  is_archived: Boolean!
  name: String!
  parent_id: uuid

  """An object relationship"""
  ref_parent: projects

  """An array relationship"""
  ref_sub_projects(
    """distinct select on columns"""
    distinct_on: [projects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [projects_order_by!]

    """filter the rows returned"""
    where: projects_bool_exp
  ): [projects!]!

  """An aggregated array relationship"""
  ref_sub_projects_aggregate(
    """distinct select on columns"""
    distinct_on: [projects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [projects_order_by!]

    """filter the rows returned"""
    where: projects_bool_exp
  ): projects_aggregate!

  """An array relationship"""
  ref_tasks(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): [tasks!]!

  """An aggregated array relationship"""
  ref_tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): tasks_aggregate!

  """An object relationship"""
  ref_team: teams
  team_id: uuid
  updated_at: timestamptz!
  user_id: String
}

"""
aggregated selection of "projects"
"""
type projects_aggregate {
  aggregate: projects_aggregate_fields
  nodes: [projects!]!
}

"""
aggregate fields of "projects"
"""
type projects_aggregate_fields {
  count(columns: [projects_select_column!], distinct: Boolean): Int
  max: projects_max_fields
  min: projects_min_fields
}

"""
order by aggregate values of table "projects"
"""
input projects_aggregate_order_by {
  count: order_by
  max: projects_max_order_by
  min: projects_min_order_by
}

"""
input type for inserting array relation for remote table "projects"
"""
input projects_arr_rel_insert_input {
  data: [projects_insert_input!]!
  on_conflict: projects_on_conflict
}

"""
Boolean expression to filter rows from the table "projects". All fields are combined with a logical 'AND'.
"""
input projects_bool_exp {
  _and: [projects_bool_exp]
  _not: projects_bool_exp
  _or: [projects_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  is_archived: Boolean_comparison_exp
  name: String_comparison_exp
  parent_id: uuid_comparison_exp
  ref_parent: projects_bool_exp
  ref_sub_projects: projects_bool_exp
  ref_tasks: tasks_bool_exp
  ref_team: teams_bool_exp
  team_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "projects"
"""
enum projects_constraint {
  """unique or primary key constraint"""
  projects_pkey
}

"""
input type for inserting data into table "projects"
"""
input projects_insert_input {
  created_at: timestamptz
  description: String
  id: uuid
  is_archived: Boolean
  name: String
  parent_id: uuid
  ref_parent: projects_obj_rel_insert_input
  ref_sub_projects: projects_arr_rel_insert_input
  ref_tasks: tasks_arr_rel_insert_input
  ref_team: teams_obj_rel_insert_input
  team_id: uuid
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type projects_max_fields {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  parent_id: uuid
  team_id: uuid
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "projects"
"""
input projects_max_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  team_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type projects_min_fields {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  parent_id: uuid
  team_id: uuid
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "projects"
"""
input projects_min_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  team_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "projects"
"""
type projects_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [projects!]!
}

"""
input type for inserting object relation for remote table "projects"
"""
input projects_obj_rel_insert_input {
  data: projects_insert_input!
  on_conflict: projects_on_conflict
}

"""
on conflict condition type for table "projects"
"""
input projects_on_conflict {
  constraint: projects_constraint!
  update_columns: [projects_update_column!]!
  where: projects_bool_exp
}

"""
ordering options when selecting data from "projects"
"""
input projects_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  is_archived: order_by
  name: order_by
  parent_id: order_by
  ref_parent: projects_order_by
  ref_sub_projects_aggregate: projects_aggregate_order_by
  ref_tasks_aggregate: tasks_aggregate_order_by
  ref_team: teams_order_by
  team_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "projects"
"""
input projects_pk_columns_input {
  id: uuid!
}

"""
select columns of table "projects"
"""
enum projects_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  is_archived

  """column name"""
  name

  """column name"""
  parent_id

  """column name"""
  team_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "projects"
"""
input projects_set_input {
  created_at: timestamptz
  description: String
  id: uuid
  is_archived: Boolean
  name: String
  parent_id: uuid
  team_id: uuid
  updated_at: timestamptz
  user_id: String
}

"""
update columns of table "projects"
"""
enum projects_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  is_archived

  """column name"""
  name

  """column name"""
  parent_id

  """column name"""
  team_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""query root"""
type query_root {
  """
  fetch data from the table: "categories"
  """
  categories(
    """distinct select on columns"""
    distinct_on: [categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [categories_order_by!]

    """filter the rows returned"""
    where: categories_bool_exp
  ): [categories!]!

  """
  fetch aggregated fields from the table: "categories"
  """
  categories_aggregate(
    """distinct select on columns"""
    distinct_on: [categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [categories_order_by!]

    """filter the rows returned"""
    where: categories_bool_exp
  ): categories_aggregate!

  """fetch data from the table: "categories" using primary key columns"""
  categories_by_pk(id: uuid!): categories

  """
  fetch data from the table: "dishes"
  """
  dishes(
    """distinct select on columns"""
    distinct_on: [dishes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dishes_order_by!]

    """filter the rows returned"""
    where: dishes_bool_exp
  ): [dishes!]!

  """
  fetch aggregated fields from the table: "dishes"
  """
  dishes_aggregate(
    """distinct select on columns"""
    distinct_on: [dishes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dishes_order_by!]

    """filter the rows returned"""
    where: dishes_bool_exp
  ): dishes_aggregate!

  """fetch data from the table: "dishes" using primary key columns"""
  dishes_by_pk(id: uuid!): dishes

  """
  fetch data from the table: "food"
  """
  food(
    """distinct select on columns"""
    distinct_on: [food_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [food_order_by!]

    """filter the rows returned"""
    where: food_bool_exp
  ): [food!]!

  """
  fetch aggregated fields from the table: "food"
  """
  food_aggregate(
    """distinct select on columns"""
    distinct_on: [food_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [food_order_by!]

    """filter the rows returned"""
    where: food_bool_exp
  ): food_aggregate!

  """fetch data from the table: "food" using primary key columns"""
  food_by_pk(id: uuid!): food

  """
  fetch data from the table: "glucose"
  """
  glucose(
    """distinct select on columns"""
    distinct_on: [glucose_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [glucose_order_by!]

    """filter the rows returned"""
    where: glucose_bool_exp
  ): [glucose!]!

  """
  fetch aggregated fields from the table: "glucose"
  """
  glucose_aggregate(
    """distinct select on columns"""
    distinct_on: [glucose_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [glucose_order_by!]

    """filter the rows returned"""
    where: glucose_bool_exp
  ): glucose_aggregate!

  """fetch data from the table: "glucose" using primary key columns"""
  glucose_by_pk(id: uuid!): glucose

  """
  fetch data from the table: "inbox"
  """
  inbox(
    """distinct select on columns"""
    distinct_on: [inbox_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inbox_order_by!]

    """filter the rows returned"""
    where: inbox_bool_exp
  ): [inbox!]!

  """
  fetch aggregated fields from the table: "inbox"
  """
  inbox_aggregate(
    """distinct select on columns"""
    distinct_on: [inbox_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inbox_order_by!]

    """filter the rows returned"""
    where: inbox_bool_exp
  ): inbox_aggregate!

  """fetch data from the table: "inbox" using primary key columns"""
  inbox_by_pk(id: Int!): inbox

  """
  fetch data from the table: "key_results"
  """
  key_results(
    """distinct select on columns"""
    distinct_on: [key_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [key_results_order_by!]

    """filter the rows returned"""
    where: key_results_bool_exp
  ): [key_results!]!

  """
  fetch aggregated fields from the table: "key_results"
  """
  key_results_aggregate(
    """distinct select on columns"""
    distinct_on: [key_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [key_results_order_by!]

    """filter the rows returned"""
    where: key_results_bool_exp
  ): key_results_aggregate!

  """fetch data from the table: "key_results" using primary key columns"""
  key_results_by_pk(id: uuid!): key_results

  """
  fetch data from the table: "notes"
  """
  notes(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): [notes!]!

  """
  fetch aggregated fields from the table: "notes"
  """
  notes_aggregate(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): notes_aggregate!

  """fetch data from the table: "notes" using primary key columns"""
  notes_by_pk(id: uuid!): notes

  """
  fetch data from the table: "notes_snippets"
  """
  notes_snippets(
    """distinct select on columns"""
    distinct_on: [notes_snippets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_snippets_order_by!]

    """filter the rows returned"""
    where: notes_snippets_bool_exp
  ): [notes_snippets!]!

  """
  fetch aggregated fields from the table: "notes_snippets"
  """
  notes_snippets_aggregate(
    """distinct select on columns"""
    distinct_on: [notes_snippets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_snippets_order_by!]

    """filter the rows returned"""
    where: notes_snippets_bool_exp
  ): notes_snippets_aggregate!

  """fetch data from the table: "notes_snippets" using primary key columns"""
  notes_snippets_by_pk(note_id: uuid!, snippet_id: uuid!): notes_snippets

  """
  fetch data from the table: "objective_team"
  """
  objective_team(
    """distinct select on columns"""
    distinct_on: [objective_team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objective_team_order_by!]

    """filter the rows returned"""
    where: objective_team_bool_exp
  ): [objective_team!]!

  """
  fetch aggregated fields from the table: "objective_team"
  """
  objective_team_aggregate(
    """distinct select on columns"""
    distinct_on: [objective_team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objective_team_order_by!]

    """filter the rows returned"""
    where: objective_team_bool_exp
  ): objective_team_aggregate!

  """fetch data from the table: "objective_team" using primary key columns"""
  objective_team_by_pk(objective_id: uuid!, team_id: uuid!): objective_team

  """
  fetch data from the table: "objectives"
  """
  objectives(
    """distinct select on columns"""
    distinct_on: [objectives_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objectives_order_by!]

    """filter the rows returned"""
    where: objectives_bool_exp
  ): [objectives!]!

  """
  fetch aggregated fields from the table: "objectives"
  """
  objectives_aggregate(
    """distinct select on columns"""
    distinct_on: [objectives_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objectives_order_by!]

    """filter the rows returned"""
    where: objectives_bool_exp
  ): objectives_aggregate!

  """fetch data from the table: "objectives" using primary key columns"""
  objectives_by_pk(id: uuid!): objectives

  """
  fetch data from the table: "people"
  """
  people(
    """distinct select on columns"""
    distinct_on: [people_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [people_order_by!]

    """filter the rows returned"""
    where: people_bool_exp
  ): [people!]!

  """
  fetch aggregated fields from the table: "people"
  """
  people_aggregate(
    """distinct select on columns"""
    distinct_on: [people_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [people_order_by!]

    """filter the rows returned"""
    where: people_bool_exp
  ): people_aggregate!

  """fetch data from the table: "people" using primary key columns"""
  people_by_pk(id: uuid!): people

  """
  fetch data from the table: "projects"
  """
  projects(
    """distinct select on columns"""
    distinct_on: [projects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [projects_order_by!]

    """filter the rows returned"""
    where: projects_bool_exp
  ): [projects!]!

  """
  fetch aggregated fields from the table: "projects"
  """
  projects_aggregate(
    """distinct select on columns"""
    distinct_on: [projects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [projects_order_by!]

    """filter the rows returned"""
    where: projects_bool_exp
  ): projects_aggregate!

  """fetch data from the table: "projects" using primary key columns"""
  projects_by_pk(id: uuid!): projects

  """
  fetch data from the table: "reviews"
  """
  reviews(
    """distinct select on columns"""
    distinct_on: [reviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reviews_order_by!]

    """filter the rows returned"""
    where: reviews_bool_exp
  ): [reviews!]!

  """
  fetch aggregated fields from the table: "reviews"
  """
  reviews_aggregate(
    """distinct select on columns"""
    distinct_on: [reviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reviews_order_by!]

    """filter the rows returned"""
    where: reviews_bool_exp
  ): reviews_aggregate!

  """fetch data from the table: "reviews" using primary key columns"""
  reviews_by_pk(id: uuid!): reviews

  """
  fetch data from the table: "snippets"
  """
  snippets(
    """distinct select on columns"""
    distinct_on: [snippets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [snippets_order_by!]

    """filter the rows returned"""
    where: snippets_bool_exp
  ): [snippets!]!

  """
  fetch aggregated fields from the table: "snippets"
  """
  snippets_aggregate(
    """distinct select on columns"""
    distinct_on: [snippets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [snippets_order_by!]

    """filter the rows returned"""
    where: snippets_bool_exp
  ): snippets_aggregate!

  """fetch data from the table: "snippets" using primary key columns"""
  snippets_by_pk(id: uuid!): snippets

  """
  fetch data from the table: "snippets_mapping"
  """
  snippets_mapping(
    """distinct select on columns"""
    distinct_on: [snippets_mapping_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [snippets_mapping_order_by!]

    """filter the rows returned"""
    where: snippets_mapping_bool_exp
  ): [snippets_mapping!]!

  """
  fetch aggregated fields from the table: "snippets_mapping"
  """
  snippets_mapping_aggregate(
    """distinct select on columns"""
    distinct_on: [snippets_mapping_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [snippets_mapping_order_by!]

    """filter the rows returned"""
    where: snippets_mapping_bool_exp
  ): snippets_mapping_aggregate!

  """
  fetch data from the table: "snippets_mapping" using primary key columns
  """
  snippets_mapping_by_pk(source_id: uuid!, target_id: uuid!): snippets_mapping

  """
  fetch data from the table: "tasks"
  """
  tasks(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): [tasks!]!

  """
  fetch aggregated fields from the table: "tasks"
  """
  tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): tasks_aggregate!

  """fetch data from the table: "tasks" using primary key columns"""
  tasks_by_pk(id: uuid!): tasks

  """
  fetch data from the table: "teams"
  """
  teams(
    """distinct select on columns"""
    distinct_on: [teams_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teams_order_by!]

    """filter the rows returned"""
    where: teams_bool_exp
  ): [teams!]!

  """
  fetch aggregated fields from the table: "teams"
  """
  teams_aggregate(
    """distinct select on columns"""
    distinct_on: [teams_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teams_order_by!]

    """filter the rows returned"""
    where: teams_bool_exp
  ): teams_aggregate!

  """fetch data from the table: "teams" using primary key columns"""
  teams_by_pk(id: uuid!): teams

  """
  fetch data from the table: "thoughts"
  """
  thoughts(
    """distinct select on columns"""
    distinct_on: [thoughts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thoughts_order_by!]

    """filter the rows returned"""
    where: thoughts_bool_exp
  ): [thoughts!]!

  """
  fetch aggregated fields from the table: "thoughts"
  """
  thoughts_aggregate(
    """distinct select on columns"""
    distinct_on: [thoughts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thoughts_order_by!]

    """filter the rows returned"""
    where: thoughts_bool_exp
  ): thoughts_aggregate!

  """fetch data from the table: "thoughts" using primary key columns"""
  thoughts_by_pk(id: uuid!): thoughts

  """
  fetch data from the table: "transactions"
  """
  transactions(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): [transactions!]!

  """
  fetch aggregated fields from the table: "transactions"
  """
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): transactions_aggregate!

  """fetch data from the table: "transactions" using primary key columns"""
  transactions_by_pk(id: uuid!): transactions

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: String!): users

  """
  fetch data from the table: "water"
  """
  water(
    """distinct select on columns"""
    distinct_on: [water_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [water_order_by!]

    """filter the rows returned"""
    where: water_bool_exp
  ): [water!]!

  """
  fetch aggregated fields from the table: "water"
  """
  water_aggregate(
    """distinct select on columns"""
    distinct_on: [water_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [water_order_by!]

    """filter the rows returned"""
    where: water_bool_exp
  ): water_aggregate!

  """fetch data from the table: "water" using primary key columns"""
  water_by_pk(id: uuid!): water

  """
  fetch data from the table: "water_till_now"
  """
  water_till_now(
    """distinct select on columns"""
    distinct_on: [water_till_now_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [water_till_now_order_by!]

    """filter the rows returned"""
    where: water_till_now_bool_exp
  ): [water_till_now!]!

  """
  fetch aggregated fields from the table: "water_till_now"
  """
  water_till_now_aggregate(
    """distinct select on columns"""
    distinct_on: [water_till_now_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [water_till_now_order_by!]

    """filter the rows returned"""
    where: water_till_now_bool_exp
  ): water_till_now_aggregate!
}

"""
columns and relationships of "reviews"
"""
type reviews {
  checklist(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz!
  id: uuid!
  scores(
    """JSON select path"""
    path: String
  ): jsonb
  summary: String
  timestamp: timestamptz!
  type: String
  updated_at: timestamptz!
  user_id: String!
}

"""
aggregated selection of "reviews"
"""
type reviews_aggregate {
  aggregate: reviews_aggregate_fields
  nodes: [reviews!]!
}

"""
aggregate fields of "reviews"
"""
type reviews_aggregate_fields {
  count(columns: [reviews_select_column!], distinct: Boolean): Int
  max: reviews_max_fields
  min: reviews_min_fields
}

"""
order by aggregate values of table "reviews"
"""
input reviews_aggregate_order_by {
  count: order_by
  max: reviews_max_order_by
  min: reviews_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input reviews_append_input {
  checklist: jsonb
  scores: jsonb
}

"""
input type for inserting array relation for remote table "reviews"
"""
input reviews_arr_rel_insert_input {
  data: [reviews_insert_input!]!
  on_conflict: reviews_on_conflict
}

"""
Boolean expression to filter rows from the table "reviews". All fields are combined with a logical 'AND'.
"""
input reviews_bool_exp {
  _and: [reviews_bool_exp]
  _not: reviews_bool_exp
  _or: [reviews_bool_exp]
  checklist: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  scores: jsonb_comparison_exp
  summary: String_comparison_exp
  timestamp: timestamptz_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "reviews"
"""
enum reviews_constraint {
  """unique or primary key constraint"""
  review_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input reviews_delete_at_path_input {
  checklist: [String]
  scores: [String]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input reviews_delete_elem_input {
  checklist: Int
  scores: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input reviews_delete_key_input {
  checklist: String
  scores: String
}

"""
input type for inserting data into table "reviews"
"""
input reviews_insert_input {
  checklist: jsonb
  created_at: timestamptz
  id: uuid
  scores: jsonb
  summary: String
  timestamp: timestamptz
  type: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type reviews_max_fields {
  created_at: timestamptz
  id: uuid
  summary: String
  timestamp: timestamptz
  type: String
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "reviews"
"""
input reviews_max_order_by {
  created_at: order_by
  id: order_by
  summary: order_by
  timestamp: order_by
  type: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type reviews_min_fields {
  created_at: timestamptz
  id: uuid
  summary: String
  timestamp: timestamptz
  type: String
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "reviews"
"""
input reviews_min_order_by {
  created_at: order_by
  id: order_by
  summary: order_by
  timestamp: order_by
  type: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "reviews"
"""
type reviews_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [reviews!]!
}

"""
input type for inserting object relation for remote table "reviews"
"""
input reviews_obj_rel_insert_input {
  data: reviews_insert_input!
  on_conflict: reviews_on_conflict
}

"""
on conflict condition type for table "reviews"
"""
input reviews_on_conflict {
  constraint: reviews_constraint!
  update_columns: [reviews_update_column!]!
  where: reviews_bool_exp
}

"""
ordering options when selecting data from "reviews"
"""
input reviews_order_by {
  checklist: order_by
  created_at: order_by
  id: order_by
  scores: order_by
  summary: order_by
  timestamp: order_by
  type: order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "reviews"
"""
input reviews_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input reviews_prepend_input {
  checklist: jsonb
  scores: jsonb
}

"""
select columns of table "reviews"
"""
enum reviews_select_column {
  """column name"""
  checklist

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  scores

  """column name"""
  summary

  """column name"""
  timestamp

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "reviews"
"""
input reviews_set_input {
  checklist: jsonb
  created_at: timestamptz
  id: uuid
  scores: jsonb
  summary: String
  timestamp: timestamptz
  type: String
  updated_at: timestamptz
  user_id: String
}

"""
update columns of table "reviews"
"""
enum reviews_update_column {
  """column name"""
  checklist

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  scores

  """column name"""
  summary

  """column name"""
  timestamp

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
columns and relationships of "snippets"
"""
type snippets {
  checkins(
    """JSON select path"""
    path: String
  ): jsonb!
  created_at: timestamptz!
  description: String
  difficulty: float8!
  due_date: timestamptz
  id: uuid!
  name: String!
  priority: Int!

  """An array relationship"""
  ref_notes(
    """distinct select on columns"""
    distinct_on: [notes_snippets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_snippets_order_by!]

    """filter the rows returned"""
    where: notes_snippets_bool_exp
  ): [notes_snippets!]!

  """An aggregated array relationship"""
  ref_notes_aggregate(
    """distinct select on columns"""
    distinct_on: [notes_snippets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_snippets_order_by!]

    """filter the rows returned"""
    where: notes_snippets_bool_exp
  ): notes_snippets_aggregate!

  """An array relationship"""
  ref_referenced_by(
    """distinct select on columns"""
    distinct_on: [snippets_mapping_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [snippets_mapping_order_by!]

    """filter the rows returned"""
    where: snippets_mapping_bool_exp
  ): [snippets_mapping!]!

  """An aggregated array relationship"""
  ref_referenced_by_aggregate(
    """distinct select on columns"""
    distinct_on: [snippets_mapping_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [snippets_mapping_order_by!]

    """filter the rows returned"""
    where: snippets_mapping_bool_exp
  ): snippets_mapping_aggregate!

  """An array relationship"""
  ref_references(
    """distinct select on columns"""
    distinct_on: [snippets_mapping_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [snippets_mapping_order_by!]

    """filter the rows returned"""
    where: snippets_mapping_bool_exp
  ): [snippets_mapping!]!

  """An aggregated array relationship"""
  ref_references_aggregate(
    """distinct select on columns"""
    distinct_on: [snippets_mapping_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [snippets_mapping_order_by!]

    """filter the rows returned"""
    where: snippets_mapping_bool_exp
  ): snippets_mapping_aggregate!
  type: String
  updated_at: timestamptz!
  user_id: String
}

"""
aggregated selection of "snippets"
"""
type snippets_aggregate {
  aggregate: snippets_aggregate_fields
  nodes: [snippets!]!
}

"""
aggregate fields of "snippets"
"""
type snippets_aggregate_fields {
  avg: snippets_avg_fields
  count(columns: [snippets_select_column!], distinct: Boolean): Int
  max: snippets_max_fields
  min: snippets_min_fields
  stddev: snippets_stddev_fields
  stddev_pop: snippets_stddev_pop_fields
  stddev_samp: snippets_stddev_samp_fields
  sum: snippets_sum_fields
  var_pop: snippets_var_pop_fields
  var_samp: snippets_var_samp_fields
  variance: snippets_variance_fields
}

"""
order by aggregate values of table "snippets"
"""
input snippets_aggregate_order_by {
  avg: snippets_avg_order_by
  count: order_by
  max: snippets_max_order_by
  min: snippets_min_order_by
  stddev: snippets_stddev_order_by
  stddev_pop: snippets_stddev_pop_order_by
  stddev_samp: snippets_stddev_samp_order_by
  sum: snippets_sum_order_by
  var_pop: snippets_var_pop_order_by
  var_samp: snippets_var_samp_order_by
  variance: snippets_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input snippets_append_input {
  checkins: jsonb
}

"""
input type for inserting array relation for remote table "snippets"
"""
input snippets_arr_rel_insert_input {
  data: [snippets_insert_input!]!
  on_conflict: snippets_on_conflict
}

"""aggregate avg on columns"""
type snippets_avg_fields {
  difficulty: Float
  priority: Float
}

"""
order by avg() on columns of table "snippets"
"""
input snippets_avg_order_by {
  difficulty: order_by
  priority: order_by
}

"""
Boolean expression to filter rows from the table "snippets". All fields are combined with a logical 'AND'.
"""
input snippets_bool_exp {
  _and: [snippets_bool_exp]
  _not: snippets_bool_exp
  _or: [snippets_bool_exp]
  checkins: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  difficulty: float8_comparison_exp
  due_date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  priority: Int_comparison_exp
  ref_notes: notes_snippets_bool_exp
  ref_referenced_by: snippets_mapping_bool_exp
  ref_references: snippets_mapping_bool_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "snippets"
"""
enum snippets_constraint {
  """unique or primary key constraint"""
  snippets_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input snippets_delete_at_path_input {
  checkins: [String]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input snippets_delete_elem_input {
  checkins: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input snippets_delete_key_input {
  checkins: String
}

"""
input type for incrementing integer column in table "snippets"
"""
input snippets_inc_input {
  difficulty: float8
  priority: Int
}

"""
input type for inserting data into table "snippets"
"""
input snippets_insert_input {
  checkins: jsonb
  created_at: timestamptz
  description: String
  difficulty: float8
  due_date: timestamptz
  id: uuid
  name: String
  priority: Int
  ref_notes: notes_snippets_arr_rel_insert_input
  ref_referenced_by: snippets_mapping_arr_rel_insert_input
  ref_references: snippets_mapping_arr_rel_insert_input
  type: String
  updated_at: timestamptz
  user_id: String
}

"""
columns and relationships of "snippets_mapping"
"""
type snippets_mapping {
  """An object relationship"""
  ref_source_snippet: snippets!

  """An object relationship"""
  ref_target_snippet: snippets!
  source_id: uuid!
  target_id: uuid!
  user_id: String
}

"""
aggregated selection of "snippets_mapping"
"""
type snippets_mapping_aggregate {
  aggregate: snippets_mapping_aggregate_fields
  nodes: [snippets_mapping!]!
}

"""
aggregate fields of "snippets_mapping"
"""
type snippets_mapping_aggregate_fields {
  count(columns: [snippets_mapping_select_column!], distinct: Boolean): Int
  max: snippets_mapping_max_fields
  min: snippets_mapping_min_fields
}

"""
order by aggregate values of table "snippets_mapping"
"""
input snippets_mapping_aggregate_order_by {
  count: order_by
  max: snippets_mapping_max_order_by
  min: snippets_mapping_min_order_by
}

"""
input type for inserting array relation for remote table "snippets_mapping"
"""
input snippets_mapping_arr_rel_insert_input {
  data: [snippets_mapping_insert_input!]!
  on_conflict: snippets_mapping_on_conflict
}

"""
Boolean expression to filter rows from the table "snippets_mapping". All fields are combined with a logical 'AND'.
"""
input snippets_mapping_bool_exp {
  _and: [snippets_mapping_bool_exp]
  _not: snippets_mapping_bool_exp
  _or: [snippets_mapping_bool_exp]
  ref_source_snippet: snippets_bool_exp
  ref_target_snippet: snippets_bool_exp
  source_id: uuid_comparison_exp
  target_id: uuid_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "snippets_mapping"
"""
enum snippets_mapping_constraint {
  """unique or primary key constraint"""
  associated_snippets_pkey
}

"""
input type for inserting data into table "snippets_mapping"
"""
input snippets_mapping_insert_input {
  ref_source_snippet: snippets_obj_rel_insert_input
  ref_target_snippet: snippets_obj_rel_insert_input
  source_id: uuid
  target_id: uuid
  user_id: String
}

"""aggregate max on columns"""
type snippets_mapping_max_fields {
  source_id: uuid
  target_id: uuid
  user_id: String
}

"""
order by max() on columns of table "snippets_mapping"
"""
input snippets_mapping_max_order_by {
  source_id: order_by
  target_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type snippets_mapping_min_fields {
  source_id: uuid
  target_id: uuid
  user_id: String
}

"""
order by min() on columns of table "snippets_mapping"
"""
input snippets_mapping_min_order_by {
  source_id: order_by
  target_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "snippets_mapping"
"""
type snippets_mapping_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [snippets_mapping!]!
}

"""
input type for inserting object relation for remote table "snippets_mapping"
"""
input snippets_mapping_obj_rel_insert_input {
  data: snippets_mapping_insert_input!
  on_conflict: snippets_mapping_on_conflict
}

"""
on conflict condition type for table "snippets_mapping"
"""
input snippets_mapping_on_conflict {
  constraint: snippets_mapping_constraint!
  update_columns: [snippets_mapping_update_column!]!
  where: snippets_mapping_bool_exp
}

"""
ordering options when selecting data from "snippets_mapping"
"""
input snippets_mapping_order_by {
  ref_source_snippet: snippets_order_by
  ref_target_snippet: snippets_order_by
  source_id: order_by
  target_id: order_by
  user_id: order_by
}

"""
primary key columns input for table: "snippets_mapping"
"""
input snippets_mapping_pk_columns_input {
  source_id: uuid!
  target_id: uuid!
}

"""
select columns of table "snippets_mapping"
"""
enum snippets_mapping_select_column {
  """column name"""
  source_id

  """column name"""
  target_id

  """column name"""
  user_id
}

"""
input type for updating data in table "snippets_mapping"
"""
input snippets_mapping_set_input {
  source_id: uuid
  target_id: uuid
  user_id: String
}

"""
update columns of table "snippets_mapping"
"""
enum snippets_mapping_update_column {
  """column name"""
  source_id

  """column name"""
  target_id

  """column name"""
  user_id
}

"""aggregate max on columns"""
type snippets_max_fields {
  created_at: timestamptz
  description: String
  difficulty: float8
  due_date: timestamptz
  id: uuid
  name: String
  priority: Int
  type: String
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "snippets"
"""
input snippets_max_order_by {
  created_at: order_by
  description: order_by
  difficulty: order_by
  due_date: order_by
  id: order_by
  name: order_by
  priority: order_by
  type: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type snippets_min_fields {
  created_at: timestamptz
  description: String
  difficulty: float8
  due_date: timestamptz
  id: uuid
  name: String
  priority: Int
  type: String
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "snippets"
"""
input snippets_min_order_by {
  created_at: order_by
  description: order_by
  difficulty: order_by
  due_date: order_by
  id: order_by
  name: order_by
  priority: order_by
  type: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "snippets"
"""
type snippets_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [snippets!]!
}

"""
input type for inserting object relation for remote table "snippets"
"""
input snippets_obj_rel_insert_input {
  data: snippets_insert_input!
  on_conflict: snippets_on_conflict
}

"""
on conflict condition type for table "snippets"
"""
input snippets_on_conflict {
  constraint: snippets_constraint!
  update_columns: [snippets_update_column!]!
  where: snippets_bool_exp
}

"""
ordering options when selecting data from "snippets"
"""
input snippets_order_by {
  checkins: order_by
  created_at: order_by
  description: order_by
  difficulty: order_by
  due_date: order_by
  id: order_by
  name: order_by
  priority: order_by
  ref_notes_aggregate: notes_snippets_aggregate_order_by
  ref_referenced_by_aggregate: snippets_mapping_aggregate_order_by
  ref_references_aggregate: snippets_mapping_aggregate_order_by
  type: order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "snippets"
"""
input snippets_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input snippets_prepend_input {
  checkins: jsonb
}

"""
select columns of table "snippets"
"""
enum snippets_select_column {
  """column name"""
  checkins

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  difficulty

  """column name"""
  due_date

  """column name"""
  id

  """column name"""
  name

  """column name"""
  priority

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "snippets"
"""
input snippets_set_input {
  checkins: jsonb
  created_at: timestamptz
  description: String
  difficulty: float8
  due_date: timestamptz
  id: uuid
  name: String
  priority: Int
  type: String
  updated_at: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type snippets_stddev_fields {
  difficulty: Float
  priority: Float
}

"""
order by stddev() on columns of table "snippets"
"""
input snippets_stddev_order_by {
  difficulty: order_by
  priority: order_by
}

"""aggregate stddev_pop on columns"""
type snippets_stddev_pop_fields {
  difficulty: Float
  priority: Float
}

"""
order by stddev_pop() on columns of table "snippets"
"""
input snippets_stddev_pop_order_by {
  difficulty: order_by
  priority: order_by
}

"""aggregate stddev_samp on columns"""
type snippets_stddev_samp_fields {
  difficulty: Float
  priority: Float
}

"""
order by stddev_samp() on columns of table "snippets"
"""
input snippets_stddev_samp_order_by {
  difficulty: order_by
  priority: order_by
}

"""aggregate sum on columns"""
type snippets_sum_fields {
  difficulty: float8
  priority: Int
}

"""
order by sum() on columns of table "snippets"
"""
input snippets_sum_order_by {
  difficulty: order_by
  priority: order_by
}

"""
update columns of table "snippets"
"""
enum snippets_update_column {
  """column name"""
  checkins

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  difficulty

  """column name"""
  due_date

  """column name"""
  id

  """column name"""
  name

  """column name"""
  priority

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type snippets_var_pop_fields {
  difficulty: Float
  priority: Float
}

"""
order by var_pop() on columns of table "snippets"
"""
input snippets_var_pop_order_by {
  difficulty: order_by
  priority: order_by
}

"""aggregate var_samp on columns"""
type snippets_var_samp_fields {
  difficulty: Float
  priority: Float
}

"""
order by var_samp() on columns of table "snippets"
"""
input snippets_var_samp_order_by {
  difficulty: order_by
  priority: order_by
}

"""aggregate variance on columns"""
type snippets_variance_fields {
  difficulty: Float
  priority: Float
}

"""
order by variance() on columns of table "snippets"
"""
input snippets_variance_order_by {
  difficulty: order_by
  priority: order_by
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"""subscription root"""
type subscription_root {
  """
  fetch data from the table: "categories"
  """
  categories(
    """distinct select on columns"""
    distinct_on: [categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [categories_order_by!]

    """filter the rows returned"""
    where: categories_bool_exp
  ): [categories!]!

  """
  fetch aggregated fields from the table: "categories"
  """
  categories_aggregate(
    """distinct select on columns"""
    distinct_on: [categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [categories_order_by!]

    """filter the rows returned"""
    where: categories_bool_exp
  ): categories_aggregate!

  """fetch data from the table: "categories" using primary key columns"""
  categories_by_pk(id: uuid!): categories

  """
  fetch data from the table: "dishes"
  """
  dishes(
    """distinct select on columns"""
    distinct_on: [dishes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dishes_order_by!]

    """filter the rows returned"""
    where: dishes_bool_exp
  ): [dishes!]!

  """
  fetch aggregated fields from the table: "dishes"
  """
  dishes_aggregate(
    """distinct select on columns"""
    distinct_on: [dishes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [dishes_order_by!]

    """filter the rows returned"""
    where: dishes_bool_exp
  ): dishes_aggregate!

  """fetch data from the table: "dishes" using primary key columns"""
  dishes_by_pk(id: uuid!): dishes

  """
  fetch data from the table: "food"
  """
  food(
    """distinct select on columns"""
    distinct_on: [food_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [food_order_by!]

    """filter the rows returned"""
    where: food_bool_exp
  ): [food!]!

  """
  fetch aggregated fields from the table: "food"
  """
  food_aggregate(
    """distinct select on columns"""
    distinct_on: [food_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [food_order_by!]

    """filter the rows returned"""
    where: food_bool_exp
  ): food_aggregate!

  """fetch data from the table: "food" using primary key columns"""
  food_by_pk(id: uuid!): food

  """
  fetch data from the table: "glucose"
  """
  glucose(
    """distinct select on columns"""
    distinct_on: [glucose_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [glucose_order_by!]

    """filter the rows returned"""
    where: glucose_bool_exp
  ): [glucose!]!

  """
  fetch aggregated fields from the table: "glucose"
  """
  glucose_aggregate(
    """distinct select on columns"""
    distinct_on: [glucose_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [glucose_order_by!]

    """filter the rows returned"""
    where: glucose_bool_exp
  ): glucose_aggregate!

  """fetch data from the table: "glucose" using primary key columns"""
  glucose_by_pk(id: uuid!): glucose

  """
  fetch data from the table: "inbox"
  """
  inbox(
    """distinct select on columns"""
    distinct_on: [inbox_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inbox_order_by!]

    """filter the rows returned"""
    where: inbox_bool_exp
  ): [inbox!]!

  """
  fetch aggregated fields from the table: "inbox"
  """
  inbox_aggregate(
    """distinct select on columns"""
    distinct_on: [inbox_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [inbox_order_by!]

    """filter the rows returned"""
    where: inbox_bool_exp
  ): inbox_aggregate!

  """fetch data from the table: "inbox" using primary key columns"""
  inbox_by_pk(id: Int!): inbox

  """
  fetch data from the table: "key_results"
  """
  key_results(
    """distinct select on columns"""
    distinct_on: [key_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [key_results_order_by!]

    """filter the rows returned"""
    where: key_results_bool_exp
  ): [key_results!]!

  """
  fetch aggregated fields from the table: "key_results"
  """
  key_results_aggregate(
    """distinct select on columns"""
    distinct_on: [key_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [key_results_order_by!]

    """filter the rows returned"""
    where: key_results_bool_exp
  ): key_results_aggregate!

  """fetch data from the table: "key_results" using primary key columns"""
  key_results_by_pk(id: uuid!): key_results

  """
  fetch data from the table: "notes"
  """
  notes(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): [notes!]!

  """
  fetch aggregated fields from the table: "notes"
  """
  notes_aggregate(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): notes_aggregate!

  """fetch data from the table: "notes" using primary key columns"""
  notes_by_pk(id: uuid!): notes

  """
  fetch data from the table: "notes_snippets"
  """
  notes_snippets(
    """distinct select on columns"""
    distinct_on: [notes_snippets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_snippets_order_by!]

    """filter the rows returned"""
    where: notes_snippets_bool_exp
  ): [notes_snippets!]!

  """
  fetch aggregated fields from the table: "notes_snippets"
  """
  notes_snippets_aggregate(
    """distinct select on columns"""
    distinct_on: [notes_snippets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_snippets_order_by!]

    """filter the rows returned"""
    where: notes_snippets_bool_exp
  ): notes_snippets_aggregate!

  """fetch data from the table: "notes_snippets" using primary key columns"""
  notes_snippets_by_pk(note_id: uuid!, snippet_id: uuid!): notes_snippets

  """
  fetch data from the table: "objective_team"
  """
  objective_team(
    """distinct select on columns"""
    distinct_on: [objective_team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objective_team_order_by!]

    """filter the rows returned"""
    where: objective_team_bool_exp
  ): [objective_team!]!

  """
  fetch aggregated fields from the table: "objective_team"
  """
  objective_team_aggregate(
    """distinct select on columns"""
    distinct_on: [objective_team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objective_team_order_by!]

    """filter the rows returned"""
    where: objective_team_bool_exp
  ): objective_team_aggregate!

  """fetch data from the table: "objective_team" using primary key columns"""
  objective_team_by_pk(objective_id: uuid!, team_id: uuid!): objective_team

  """
  fetch data from the table: "objectives"
  """
  objectives(
    """distinct select on columns"""
    distinct_on: [objectives_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objectives_order_by!]

    """filter the rows returned"""
    where: objectives_bool_exp
  ): [objectives!]!

  """
  fetch aggregated fields from the table: "objectives"
  """
  objectives_aggregate(
    """distinct select on columns"""
    distinct_on: [objectives_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objectives_order_by!]

    """filter the rows returned"""
    where: objectives_bool_exp
  ): objectives_aggregate!

  """fetch data from the table: "objectives" using primary key columns"""
  objectives_by_pk(id: uuid!): objectives

  """
  fetch data from the table: "people"
  """
  people(
    """distinct select on columns"""
    distinct_on: [people_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [people_order_by!]

    """filter the rows returned"""
    where: people_bool_exp
  ): [people!]!

  """
  fetch aggregated fields from the table: "people"
  """
  people_aggregate(
    """distinct select on columns"""
    distinct_on: [people_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [people_order_by!]

    """filter the rows returned"""
    where: people_bool_exp
  ): people_aggregate!

  """fetch data from the table: "people" using primary key columns"""
  people_by_pk(id: uuid!): people

  """
  fetch data from the table: "projects"
  """
  projects(
    """distinct select on columns"""
    distinct_on: [projects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [projects_order_by!]

    """filter the rows returned"""
    where: projects_bool_exp
  ): [projects!]!

  """
  fetch aggregated fields from the table: "projects"
  """
  projects_aggregate(
    """distinct select on columns"""
    distinct_on: [projects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [projects_order_by!]

    """filter the rows returned"""
    where: projects_bool_exp
  ): projects_aggregate!

  """fetch data from the table: "projects" using primary key columns"""
  projects_by_pk(id: uuid!): projects

  """
  fetch data from the table: "reviews"
  """
  reviews(
    """distinct select on columns"""
    distinct_on: [reviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reviews_order_by!]

    """filter the rows returned"""
    where: reviews_bool_exp
  ): [reviews!]!

  """
  fetch aggregated fields from the table: "reviews"
  """
  reviews_aggregate(
    """distinct select on columns"""
    distinct_on: [reviews_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reviews_order_by!]

    """filter the rows returned"""
    where: reviews_bool_exp
  ): reviews_aggregate!

  """fetch data from the table: "reviews" using primary key columns"""
  reviews_by_pk(id: uuid!): reviews

  """
  fetch data from the table: "snippets"
  """
  snippets(
    """distinct select on columns"""
    distinct_on: [snippets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [snippets_order_by!]

    """filter the rows returned"""
    where: snippets_bool_exp
  ): [snippets!]!

  """
  fetch aggregated fields from the table: "snippets"
  """
  snippets_aggregate(
    """distinct select on columns"""
    distinct_on: [snippets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [snippets_order_by!]

    """filter the rows returned"""
    where: snippets_bool_exp
  ): snippets_aggregate!

  """fetch data from the table: "snippets" using primary key columns"""
  snippets_by_pk(id: uuid!): snippets

  """
  fetch data from the table: "snippets_mapping"
  """
  snippets_mapping(
    """distinct select on columns"""
    distinct_on: [snippets_mapping_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [snippets_mapping_order_by!]

    """filter the rows returned"""
    where: snippets_mapping_bool_exp
  ): [snippets_mapping!]!

  """
  fetch aggregated fields from the table: "snippets_mapping"
  """
  snippets_mapping_aggregate(
    """distinct select on columns"""
    distinct_on: [snippets_mapping_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [snippets_mapping_order_by!]

    """filter the rows returned"""
    where: snippets_mapping_bool_exp
  ): snippets_mapping_aggregate!

  """
  fetch data from the table: "snippets_mapping" using primary key columns
  """
  snippets_mapping_by_pk(source_id: uuid!, target_id: uuid!): snippets_mapping

  """
  fetch data from the table: "tasks"
  """
  tasks(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): [tasks!]!

  """
  fetch aggregated fields from the table: "tasks"
  """
  tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): tasks_aggregate!

  """fetch data from the table: "tasks" using primary key columns"""
  tasks_by_pk(id: uuid!): tasks

  """
  fetch data from the table: "teams"
  """
  teams(
    """distinct select on columns"""
    distinct_on: [teams_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teams_order_by!]

    """filter the rows returned"""
    where: teams_bool_exp
  ): [teams!]!

  """
  fetch aggregated fields from the table: "teams"
  """
  teams_aggregate(
    """distinct select on columns"""
    distinct_on: [teams_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [teams_order_by!]

    """filter the rows returned"""
    where: teams_bool_exp
  ): teams_aggregate!

  """fetch data from the table: "teams" using primary key columns"""
  teams_by_pk(id: uuid!): teams

  """
  fetch data from the table: "thoughts"
  """
  thoughts(
    """distinct select on columns"""
    distinct_on: [thoughts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thoughts_order_by!]

    """filter the rows returned"""
    where: thoughts_bool_exp
  ): [thoughts!]!

  """
  fetch aggregated fields from the table: "thoughts"
  """
  thoughts_aggregate(
    """distinct select on columns"""
    distinct_on: [thoughts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [thoughts_order_by!]

    """filter the rows returned"""
    where: thoughts_bool_exp
  ): thoughts_aggregate!

  """fetch data from the table: "thoughts" using primary key columns"""
  thoughts_by_pk(id: uuid!): thoughts

  """
  fetch data from the table: "transactions"
  """
  transactions(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): [transactions!]!

  """
  fetch aggregated fields from the table: "transactions"
  """
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): transactions_aggregate!

  """fetch data from the table: "transactions" using primary key columns"""
  transactions_by_pk(id: uuid!): transactions

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: String!): users

  """
  fetch data from the table: "water"
  """
  water(
    """distinct select on columns"""
    distinct_on: [water_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [water_order_by!]

    """filter the rows returned"""
    where: water_bool_exp
  ): [water!]!

  """
  fetch aggregated fields from the table: "water"
  """
  water_aggregate(
    """distinct select on columns"""
    distinct_on: [water_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [water_order_by!]

    """filter the rows returned"""
    where: water_bool_exp
  ): water_aggregate!

  """fetch data from the table: "water" using primary key columns"""
  water_by_pk(id: uuid!): water

  """
  fetch data from the table: "water_till_now"
  """
  water_till_now(
    """distinct select on columns"""
    distinct_on: [water_till_now_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [water_till_now_order_by!]

    """filter the rows returned"""
    where: water_till_now_bool_exp
  ): [water_till_now!]!

  """
  fetch aggregated fields from the table: "water_till_now"
  """
  water_till_now_aggregate(
    """distinct select on columns"""
    distinct_on: [water_till_now_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [water_till_now_order_by!]

    """filter the rows returned"""
    where: water_till_now_bool_exp
  ): water_till_now_aggregate!
}

"""
columns and relationships of "tasks"
"""
type tasks {
  checklist(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz!
  description: String
  due_date: timestamptz
  id: uuid!
  name: String!
  parent_id: uuid
  people_id: uuid
  priority: String!
  project_id: uuid

  """An object relationship"""
  ref_parent: tasks

  """An object relationship"""
  ref_person: people

  """An object relationship"""
  ref_project: projects

  """An array relationship"""
  ref_sub_tasks(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): [tasks!]!

  """An aggregated array relationship"""
  ref_sub_tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): tasks_aggregate!

  """An object relationship"""
  ref_team: teams
  status: String!
  team: String
  team_id: uuid
  updated_at: timestamptz!
  user_id: String
}

"""
aggregated selection of "tasks"
"""
type tasks_aggregate {
  aggregate: tasks_aggregate_fields
  nodes: [tasks!]!
}

"""
aggregate fields of "tasks"
"""
type tasks_aggregate_fields {
  count(columns: [tasks_select_column!], distinct: Boolean): Int
  max: tasks_max_fields
  min: tasks_min_fields
}

"""
order by aggregate values of table "tasks"
"""
input tasks_aggregate_order_by {
  count: order_by
  max: tasks_max_order_by
  min: tasks_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input tasks_append_input {
  checklist: jsonb
}

"""
input type for inserting array relation for remote table "tasks"
"""
input tasks_arr_rel_insert_input {
  data: [tasks_insert_input!]!
  on_conflict: tasks_on_conflict
}

"""
Boolean expression to filter rows from the table "tasks". All fields are combined with a logical 'AND'.
"""
input tasks_bool_exp {
  _and: [tasks_bool_exp]
  _not: tasks_bool_exp
  _or: [tasks_bool_exp]
  checklist: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  due_date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  parent_id: uuid_comparison_exp
  people_id: uuid_comparison_exp
  priority: String_comparison_exp
  project_id: uuid_comparison_exp
  ref_parent: tasks_bool_exp
  ref_person: people_bool_exp
  ref_project: projects_bool_exp
  ref_sub_tasks: tasks_bool_exp
  ref_team: teams_bool_exp
  status: String_comparison_exp
  team: String_comparison_exp
  team_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "tasks"
"""
enum tasks_constraint {
  """unique or primary key constraint"""
  tasks_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input tasks_delete_at_path_input {
  checklist: [String]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input tasks_delete_elem_input {
  checklist: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input tasks_delete_key_input {
  checklist: String
}

"""
input type for inserting data into table "tasks"
"""
input tasks_insert_input {
  checklist: jsonb
  created_at: timestamptz
  description: String
  due_date: timestamptz
  id: uuid
  name: String
  parent_id: uuid
  people_id: uuid
  priority: String
  project_id: uuid
  ref_parent: tasks_obj_rel_insert_input
  ref_person: people_obj_rel_insert_input
  ref_project: projects_obj_rel_insert_input
  ref_sub_tasks: tasks_arr_rel_insert_input
  ref_team: teams_obj_rel_insert_input
  status: String
  team: String
  team_id: uuid
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type tasks_max_fields {
  created_at: timestamptz
  description: String
  due_date: timestamptz
  id: uuid
  name: String
  parent_id: uuid
  people_id: uuid
  priority: String
  project_id: uuid
  status: String
  team: String
  team_id: uuid
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "tasks"
"""
input tasks_max_order_by {
  created_at: order_by
  description: order_by
  due_date: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  people_id: order_by
  priority: order_by
  project_id: order_by
  status: order_by
  team: order_by
  team_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type tasks_min_fields {
  created_at: timestamptz
  description: String
  due_date: timestamptz
  id: uuid
  name: String
  parent_id: uuid
  people_id: uuid
  priority: String
  project_id: uuid
  status: String
  team: String
  team_id: uuid
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "tasks"
"""
input tasks_min_order_by {
  created_at: order_by
  description: order_by
  due_date: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  people_id: order_by
  priority: order_by
  project_id: order_by
  status: order_by
  team: order_by
  team_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "tasks"
"""
type tasks_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [tasks!]!
}

"""
input type for inserting object relation for remote table "tasks"
"""
input tasks_obj_rel_insert_input {
  data: tasks_insert_input!
  on_conflict: tasks_on_conflict
}

"""
on conflict condition type for table "tasks"
"""
input tasks_on_conflict {
  constraint: tasks_constraint!
  update_columns: [tasks_update_column!]!
  where: tasks_bool_exp
}

"""
ordering options when selecting data from "tasks"
"""
input tasks_order_by {
  checklist: order_by
  created_at: order_by
  description: order_by
  due_date: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  people_id: order_by
  priority: order_by
  project_id: order_by
  ref_parent: tasks_order_by
  ref_person: people_order_by
  ref_project: projects_order_by
  ref_sub_tasks_aggregate: tasks_aggregate_order_by
  ref_team: teams_order_by
  status: order_by
  team: order_by
  team_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "tasks"
"""
input tasks_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input tasks_prepend_input {
  checklist: jsonb
}

"""
select columns of table "tasks"
"""
enum tasks_select_column {
  """column name"""
  checklist

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  due_date

  """column name"""
  id

  """column name"""
  name

  """column name"""
  parent_id

  """column name"""
  people_id

  """column name"""
  priority

  """column name"""
  project_id

  """column name"""
  status

  """column name"""
  team

  """column name"""
  team_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "tasks"
"""
input tasks_set_input {
  checklist: jsonb
  created_at: timestamptz
  description: String
  due_date: timestamptz
  id: uuid
  name: String
  parent_id: uuid
  people_id: uuid
  priority: String
  project_id: uuid
  status: String
  team: String
  team_id: uuid
  updated_at: timestamptz
  user_id: String
}

"""
update columns of table "tasks"
"""
enum tasks_update_column {
  """column name"""
  checklist

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  due_date

  """column name"""
  id

  """column name"""
  name

  """column name"""
  parent_id

  """column name"""
  people_id

  """column name"""
  priority

  """column name"""
  project_id

  """column name"""
  status

  """column name"""
  team

  """column name"""
  team_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
columns and relationships of "teams"
"""
type teams {
  created_at: timestamptz!
  description: String
  id: uuid!
  name: String!

  """An array relationship"""
  ref_objective_teams(
    """distinct select on columns"""
    distinct_on: [objective_team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objective_team_order_by!]

    """filter the rows returned"""
    where: objective_team_bool_exp
  ): [objective_team!]!

  """An aggregated array relationship"""
  ref_objective_teams_aggregate(
    """distinct select on columns"""
    distinct_on: [objective_team_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objective_team_order_by!]

    """filter the rows returned"""
    where: objective_team_bool_exp
  ): objective_team_aggregate!

  """An array relationship"""
  ref_projects(
    """distinct select on columns"""
    distinct_on: [projects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [projects_order_by!]

    """filter the rows returned"""
    where: projects_bool_exp
  ): [projects!]!

  """An aggregated array relationship"""
  ref_projects_aggregate(
    """distinct select on columns"""
    distinct_on: [projects_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [projects_order_by!]

    """filter the rows returned"""
    where: projects_bool_exp
  ): projects_aggregate!

  """An array relationship"""
  ref_tasks(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): [tasks!]!

  """An aggregated array relationship"""
  ref_tasks_aggregate(
    """distinct select on columns"""
    distinct_on: [tasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tasks_order_by!]

    """filter the rows returned"""
    where: tasks_bool_exp
  ): tasks_aggregate!
  updated_at: timestamptz!
  user_id: String
}

"""
aggregated selection of "teams"
"""
type teams_aggregate {
  aggregate: teams_aggregate_fields
  nodes: [teams!]!
}

"""
aggregate fields of "teams"
"""
type teams_aggregate_fields {
  count(columns: [teams_select_column!], distinct: Boolean): Int
  max: teams_max_fields
  min: teams_min_fields
}

"""
order by aggregate values of table "teams"
"""
input teams_aggregate_order_by {
  count: order_by
  max: teams_max_order_by
  min: teams_min_order_by
}

"""
input type for inserting array relation for remote table "teams"
"""
input teams_arr_rel_insert_input {
  data: [teams_insert_input!]!
  on_conflict: teams_on_conflict
}

"""
Boolean expression to filter rows from the table "teams". All fields are combined with a logical 'AND'.
"""
input teams_bool_exp {
  _and: [teams_bool_exp]
  _not: teams_bool_exp
  _or: [teams_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  ref_objective_teams: objective_team_bool_exp
  ref_projects: projects_bool_exp
  ref_tasks: tasks_bool_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "teams"
"""
enum teams_constraint {
  """unique or primary key constraint"""
  teams_pkey
}

"""
input type for inserting data into table "teams"
"""
input teams_insert_input {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  ref_objective_teams: objective_team_arr_rel_insert_input
  ref_projects: projects_arr_rel_insert_input
  ref_tasks: tasks_arr_rel_insert_input
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type teams_max_fields {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "teams"
"""
input teams_max_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type teams_min_fields {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "teams"
"""
input teams_min_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "teams"
"""
type teams_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [teams!]!
}

"""
input type for inserting object relation for remote table "teams"
"""
input teams_obj_rel_insert_input {
  data: teams_insert_input!
  on_conflict: teams_on_conflict
}

"""
on conflict condition type for table "teams"
"""
input teams_on_conflict {
  constraint: teams_constraint!
  update_columns: [teams_update_column!]!
  where: teams_bool_exp
}

"""
ordering options when selecting data from "teams"
"""
input teams_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  ref_objective_teams_aggregate: objective_team_aggregate_order_by
  ref_projects_aggregate: projects_aggregate_order_by
  ref_tasks_aggregate: tasks_aggregate_order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "teams"
"""
input teams_pk_columns_input {
  id: uuid!
}

"""
select columns of table "teams"
"""
enum teams_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "teams"
"""
input teams_set_input {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  updated_at: timestamptz
  user_id: String
}

"""
update columns of table "teams"
"""
enum teams_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
columns and relationships of "thoughts"
"""
type thoughts {
  created_at: timestamptz!
  description: String
  id: uuid!
  name: String!
  project_id: uuid

  """An object relationship"""
  ref_project: projects

  """An object relationship"""
  ref_task: tasks

  """An object relationship"""
  ref_team: teams
  task_id: uuid
  team_id: uuid
  updated_at: timestamptz!
  user_id: String!
}

"""
aggregated selection of "thoughts"
"""
type thoughts_aggregate {
  aggregate: thoughts_aggregate_fields
  nodes: [thoughts!]!
}

"""
aggregate fields of "thoughts"
"""
type thoughts_aggregate_fields {
  count(columns: [thoughts_select_column!], distinct: Boolean): Int
  max: thoughts_max_fields
  min: thoughts_min_fields
}

"""
order by aggregate values of table "thoughts"
"""
input thoughts_aggregate_order_by {
  count: order_by
  max: thoughts_max_order_by
  min: thoughts_min_order_by
}

"""
input type for inserting array relation for remote table "thoughts"
"""
input thoughts_arr_rel_insert_input {
  data: [thoughts_insert_input!]!
  on_conflict: thoughts_on_conflict
}

"""
Boolean expression to filter rows from the table "thoughts". All fields are combined with a logical 'AND'.
"""
input thoughts_bool_exp {
  _and: [thoughts_bool_exp]
  _not: thoughts_bool_exp
  _or: [thoughts_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  project_id: uuid_comparison_exp
  ref_project: projects_bool_exp
  ref_task: tasks_bool_exp
  ref_team: teams_bool_exp
  task_id: uuid_comparison_exp
  team_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "thoughts"
"""
enum thoughts_constraint {
  """unique or primary key constraint"""
  thoughts_pkey
}

"""
input type for inserting data into table "thoughts"
"""
input thoughts_insert_input {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  project_id: uuid
  ref_project: projects_obj_rel_insert_input
  ref_task: tasks_obj_rel_insert_input
  ref_team: teams_obj_rel_insert_input
  task_id: uuid
  team_id: uuid
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type thoughts_max_fields {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  project_id: uuid
  task_id: uuid
  team_id: uuid
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "thoughts"
"""
input thoughts_max_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  project_id: order_by
  task_id: order_by
  team_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type thoughts_min_fields {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  project_id: uuid
  task_id: uuid
  team_id: uuid
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "thoughts"
"""
input thoughts_min_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  project_id: order_by
  task_id: order_by
  team_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "thoughts"
"""
type thoughts_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [thoughts!]!
}

"""
input type for inserting object relation for remote table "thoughts"
"""
input thoughts_obj_rel_insert_input {
  data: thoughts_insert_input!
  on_conflict: thoughts_on_conflict
}

"""
on conflict condition type for table "thoughts"
"""
input thoughts_on_conflict {
  constraint: thoughts_constraint!
  update_columns: [thoughts_update_column!]!
  where: thoughts_bool_exp
}

"""
ordering options when selecting data from "thoughts"
"""
input thoughts_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  project_id: order_by
  ref_project: projects_order_by
  ref_task: tasks_order_by
  ref_team: teams_order_by
  task_id: order_by
  team_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "thoughts"
"""
input thoughts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "thoughts"
"""
enum thoughts_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  project_id

  """column name"""
  task_id

  """column name"""
  team_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "thoughts"
"""
input thoughts_set_input {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  project_id: uuid
  task_id: uuid
  team_id: uuid
  updated_at: timestamptz
  user_id: String
}

"""
update columns of table "thoughts"
"""
enum thoughts_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  project_id

  """column name"""
  task_id

  """column name"""
  team_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

scalar timestamptz

"""
expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "transactions"
"""
type transactions {
  category_id: uuid
  created_at: timestamptz!
  description: String
  id: uuid!
  mode: String
  name: String!
  planned_at: timestamptz

  """An object relationship"""
  ref_category: categories
  team: String
  timestamp: timestamptz!
  type: String!
  updated_at: timestamptz!
  user_id: String
  value: float8!
}

"""
aggregated selection of "transactions"
"""
type transactions_aggregate {
  aggregate: transactions_aggregate_fields
  nodes: [transactions!]!
}

"""
aggregate fields of "transactions"
"""
type transactions_aggregate_fields {
  avg: transactions_avg_fields
  count(columns: [transactions_select_column!], distinct: Boolean): Int
  max: transactions_max_fields
  min: transactions_min_fields
  stddev: transactions_stddev_fields
  stddev_pop: transactions_stddev_pop_fields
  stddev_samp: transactions_stddev_samp_fields
  sum: transactions_sum_fields
  var_pop: transactions_var_pop_fields
  var_samp: transactions_var_samp_fields
  variance: transactions_variance_fields
}

"""
order by aggregate values of table "transactions"
"""
input transactions_aggregate_order_by {
  avg: transactions_avg_order_by
  count: order_by
  max: transactions_max_order_by
  min: transactions_min_order_by
  stddev: transactions_stddev_order_by
  stddev_pop: transactions_stddev_pop_order_by
  stddev_samp: transactions_stddev_samp_order_by
  sum: transactions_sum_order_by
  var_pop: transactions_var_pop_order_by
  var_samp: transactions_var_samp_order_by
  variance: transactions_variance_order_by
}

"""
input type for inserting array relation for remote table "transactions"
"""
input transactions_arr_rel_insert_input {
  data: [transactions_insert_input!]!
  on_conflict: transactions_on_conflict
}

"""aggregate avg on columns"""
type transactions_avg_fields {
  value: Float
}

"""
order by avg() on columns of table "transactions"
"""
input transactions_avg_order_by {
  value: order_by
}

"""
Boolean expression to filter rows from the table "transactions". All fields are combined with a logical 'AND'.
"""
input transactions_bool_exp {
  _and: [transactions_bool_exp]
  _not: transactions_bool_exp
  _or: [transactions_bool_exp]
  category_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  mode: String_comparison_exp
  name: String_comparison_exp
  planned_at: timestamptz_comparison_exp
  ref_category: categories_bool_exp
  team: String_comparison_exp
  timestamp: timestamptz_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
  value: float8_comparison_exp
}

"""
unique or primary key constraints on table "transactions"
"""
enum transactions_constraint {
  """unique or primary key constraint"""
  transactions_pkey
}

"""
input type for incrementing integer column in table "transactions"
"""
input transactions_inc_input {
  value: float8
}

"""
input type for inserting data into table "transactions"
"""
input transactions_insert_input {
  category_id: uuid
  created_at: timestamptz
  description: String
  id: uuid
  mode: String
  name: String
  planned_at: timestamptz
  ref_category: categories_obj_rel_insert_input
  team: String
  timestamp: timestamptz
  type: String
  updated_at: timestamptz
  user_id: String
  value: float8
}

"""aggregate max on columns"""
type transactions_max_fields {
  category_id: uuid
  created_at: timestamptz
  description: String
  id: uuid
  mode: String
  name: String
  planned_at: timestamptz
  team: String
  timestamp: timestamptz
  type: String
  updated_at: timestamptz
  user_id: String
  value: float8
}

"""
order by max() on columns of table "transactions"
"""
input transactions_max_order_by {
  category_id: order_by
  created_at: order_by
  description: order_by
  id: order_by
  mode: order_by
  name: order_by
  planned_at: order_by
  team: order_by
  timestamp: order_by
  type: order_by
  updated_at: order_by
  user_id: order_by
  value: order_by
}

"""aggregate min on columns"""
type transactions_min_fields {
  category_id: uuid
  created_at: timestamptz
  description: String
  id: uuid
  mode: String
  name: String
  planned_at: timestamptz
  team: String
  timestamp: timestamptz
  type: String
  updated_at: timestamptz
  user_id: String
  value: float8
}

"""
order by min() on columns of table "transactions"
"""
input transactions_min_order_by {
  category_id: order_by
  created_at: order_by
  description: order_by
  id: order_by
  mode: order_by
  name: order_by
  planned_at: order_by
  team: order_by
  timestamp: order_by
  type: order_by
  updated_at: order_by
  user_id: order_by
  value: order_by
}

"""
response of any mutation on the table "transactions"
"""
type transactions_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [transactions!]!
}

"""
input type for inserting object relation for remote table "transactions"
"""
input transactions_obj_rel_insert_input {
  data: transactions_insert_input!
  on_conflict: transactions_on_conflict
}

"""
on conflict condition type for table "transactions"
"""
input transactions_on_conflict {
  constraint: transactions_constraint!
  update_columns: [transactions_update_column!]!
  where: transactions_bool_exp
}

"""
ordering options when selecting data from "transactions"
"""
input transactions_order_by {
  category_id: order_by
  created_at: order_by
  description: order_by
  id: order_by
  mode: order_by
  name: order_by
  planned_at: order_by
  ref_category: categories_order_by
  team: order_by
  timestamp: order_by
  type: order_by
  updated_at: order_by
  user_id: order_by
  value: order_by
}

"""
primary key columns input for table: "transactions"
"""
input transactions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "transactions"
"""
enum transactions_select_column {
  """column name"""
  category_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  mode

  """column name"""
  name

  """column name"""
  planned_at

  """column name"""
  team

  """column name"""
  timestamp

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  value
}

"""
input type for updating data in table "transactions"
"""
input transactions_set_input {
  category_id: uuid
  created_at: timestamptz
  description: String
  id: uuid
  mode: String
  name: String
  planned_at: timestamptz
  team: String
  timestamp: timestamptz
  type: String
  updated_at: timestamptz
  user_id: String
  value: float8
}

"""aggregate stddev on columns"""
type transactions_stddev_fields {
  value: Float
}

"""
order by stddev() on columns of table "transactions"
"""
input transactions_stddev_order_by {
  value: order_by
}

"""aggregate stddev_pop on columns"""
type transactions_stddev_pop_fields {
  value: Float
}

"""
order by stddev_pop() on columns of table "transactions"
"""
input transactions_stddev_pop_order_by {
  value: order_by
}

"""aggregate stddev_samp on columns"""
type transactions_stddev_samp_fields {
  value: Float
}

"""
order by stddev_samp() on columns of table "transactions"
"""
input transactions_stddev_samp_order_by {
  value: order_by
}

"""aggregate sum on columns"""
type transactions_sum_fields {
  value: float8
}

"""
order by sum() on columns of table "transactions"
"""
input transactions_sum_order_by {
  value: order_by
}

"""
update columns of table "transactions"
"""
enum transactions_update_column {
  """column name"""
  category_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  mode

  """column name"""
  name

  """column name"""
  planned_at

  """column name"""
  team

  """column name"""
  timestamp

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  value
}

"""aggregate var_pop on columns"""
type transactions_var_pop_fields {
  value: Float
}

"""
order by var_pop() on columns of table "transactions"
"""
input transactions_var_pop_order_by {
  value: order_by
}

"""aggregate var_samp on columns"""
type transactions_var_samp_fields {
  value: Float
}

"""
order by var_samp() on columns of table "transactions"
"""
input transactions_var_samp_order_by {
  value: order_by
}

"""aggregate variance on columns"""
type transactions_variance_fields {
  value: Float
}

"""
order by variance() on columns of table "transactions"
"""
input transactions_variance_order_by {
  value: order_by
}

"""
columns and relationships of "users"
"""
type users {
  created_at: timestamptz!
  id: String!
  last_seen: timestamptz
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp]
  _not: users_bool_exp
  _or: [users_bool_exp]
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  last_seen: timestamptz_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """unique or primary key constraint"""
  users_pkey
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  created_at: timestamptz
  id: String
  last_seen: timestamptz
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type users_max_fields {
  created_at: timestamptz
  id: String
  last_seen: timestamptz
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "users"
"""
input users_max_order_by {
  created_at: order_by
  id: order_by
  last_seen: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  created_at: timestamptz
  id: String
  last_seen: timestamptz
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "users"
"""
input users_min_order_by {
  created_at: order_by
  id: order_by
  last_seen: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!
  on_conflict: users_on_conflict
}

"""
on conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]!
  where: users_bool_exp
}

"""
ordering options when selecting data from "users"
"""
input users_order_by {
  created_at: order_by
  id: order_by
  last_seen: order_by
  name: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "users"
"""
input users_pk_columns_input {
  id: String!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  last_seen

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  created_at: timestamptz
  id: String
  last_seen: timestamptz
  name: String
  updated_at: timestamptz
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  last_seen

  """column name"""
  name

  """column name"""
  updated_at
}

scalar uuid

"""
expression to compare columns of type uuid. All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "water"
"""
type water {
  created_at: timestamptz!
  description: String
  id: uuid!
  quantity: Int!
  timestamp: timestamptz!
  updated_at: timestamptz!
  user_id: String
}

"""
aggregated selection of "water"
"""
type water_aggregate {
  aggregate: water_aggregate_fields
  nodes: [water!]!
}

"""
aggregate fields of "water"
"""
type water_aggregate_fields {
  avg: water_avg_fields
  count(columns: [water_select_column!], distinct: Boolean): Int
  max: water_max_fields
  min: water_min_fields
  stddev: water_stddev_fields
  stddev_pop: water_stddev_pop_fields
  stddev_samp: water_stddev_samp_fields
  sum: water_sum_fields
  var_pop: water_var_pop_fields
  var_samp: water_var_samp_fields
  variance: water_variance_fields
}

"""
order by aggregate values of table "water"
"""
input water_aggregate_order_by {
  avg: water_avg_order_by
  count: order_by
  max: water_max_order_by
  min: water_min_order_by
  stddev: water_stddev_order_by
  stddev_pop: water_stddev_pop_order_by
  stddev_samp: water_stddev_samp_order_by
  sum: water_sum_order_by
  var_pop: water_var_pop_order_by
  var_samp: water_var_samp_order_by
  variance: water_variance_order_by
}

"""
input type for inserting array relation for remote table "water"
"""
input water_arr_rel_insert_input {
  data: [water_insert_input!]!
  on_conflict: water_on_conflict
}

"""aggregate avg on columns"""
type water_avg_fields {
  quantity: Float
}

"""
order by avg() on columns of table "water"
"""
input water_avg_order_by {
  quantity: order_by
}

"""
Boolean expression to filter rows from the table "water". All fields are combined with a logical 'AND'.
"""
input water_bool_exp {
  _and: [water_bool_exp]
  _not: water_bool_exp
  _or: [water_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  quantity: Int_comparison_exp
  timestamp: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "water"
"""
enum water_constraint {
  """unique or primary key constraint"""
  water_pkey
}

"""
input type for incrementing integer column in table "water"
"""
input water_inc_input {
  quantity: Int
}

"""
input type for inserting data into table "water"
"""
input water_insert_input {
  created_at: timestamptz
  description: String
  id: uuid
  quantity: Int
  timestamp: timestamptz
  updated_at: timestamptz
  user_id: String
}

"""aggregate max on columns"""
type water_max_fields {
  created_at: timestamptz
  description: String
  id: uuid
  quantity: Int
  timestamp: timestamptz
  updated_at: timestamptz
  user_id: String
}

"""
order by max() on columns of table "water"
"""
input water_max_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  quantity: order_by
  timestamp: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type water_min_fields {
  created_at: timestamptz
  description: String
  id: uuid
  quantity: Int
  timestamp: timestamptz
  updated_at: timestamptz
  user_id: String
}

"""
order by min() on columns of table "water"
"""
input water_min_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  quantity: order_by
  timestamp: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "water"
"""
type water_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [water!]!
}

"""
input type for inserting object relation for remote table "water"
"""
input water_obj_rel_insert_input {
  data: water_insert_input!
  on_conflict: water_on_conflict
}

"""
on conflict condition type for table "water"
"""
input water_on_conflict {
  constraint: water_constraint!
  update_columns: [water_update_column!]!
  where: water_bool_exp
}

"""
ordering options when selecting data from "water"
"""
input water_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  quantity: order_by
  timestamp: order_by
  updated_at: order_by
  user_id: order_by
}

"""
primary key columns input for table: "water"
"""
input water_pk_columns_input {
  id: uuid!
}

"""
select columns of table "water"
"""
enum water_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  quantity

  """column name"""
  timestamp

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "water"
"""
input water_set_input {
  created_at: timestamptz
  description: String
  id: uuid
  quantity: Int
  timestamp: timestamptz
  updated_at: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type water_stddev_fields {
  quantity: Float
}

"""
order by stddev() on columns of table "water"
"""
input water_stddev_order_by {
  quantity: order_by
}

"""aggregate stddev_pop on columns"""
type water_stddev_pop_fields {
  quantity: Float
}

"""
order by stddev_pop() on columns of table "water"
"""
input water_stddev_pop_order_by {
  quantity: order_by
}

"""aggregate stddev_samp on columns"""
type water_stddev_samp_fields {
  quantity: Float
}

"""
order by stddev_samp() on columns of table "water"
"""
input water_stddev_samp_order_by {
  quantity: order_by
}

"""aggregate sum on columns"""
type water_sum_fields {
  quantity: Int
}

"""
order by sum() on columns of table "water"
"""
input water_sum_order_by {
  quantity: order_by
}

"""
columns and relationships of "water_till_now"
"""
type water_till_now {
  avg: numeric
}

"""
aggregated selection of "water_till_now"
"""
type water_till_now_aggregate {
  aggregate: water_till_now_aggregate_fields
  nodes: [water_till_now!]!
}

"""
aggregate fields of "water_till_now"
"""
type water_till_now_aggregate_fields {
  avg: water_till_now_avg_fields
  count(columns: [water_till_now_select_column!], distinct: Boolean): Int
  max: water_till_now_max_fields
  min: water_till_now_min_fields
  stddev: water_till_now_stddev_fields
  stddev_pop: water_till_now_stddev_pop_fields
  stddev_samp: water_till_now_stddev_samp_fields
  sum: water_till_now_sum_fields
  var_pop: water_till_now_var_pop_fields
  var_samp: water_till_now_var_samp_fields
  variance: water_till_now_variance_fields
}

"""
order by aggregate values of table "water_till_now"
"""
input water_till_now_aggregate_order_by {
  avg: water_till_now_avg_order_by
  count: order_by
  max: water_till_now_max_order_by
  min: water_till_now_min_order_by
  stddev: water_till_now_stddev_order_by
  stddev_pop: water_till_now_stddev_pop_order_by
  stddev_samp: water_till_now_stddev_samp_order_by
  sum: water_till_now_sum_order_by
  var_pop: water_till_now_var_pop_order_by
  var_samp: water_till_now_var_samp_order_by
  variance: water_till_now_variance_order_by
}

"""aggregate avg on columns"""
type water_till_now_avg_fields {
  avg: Float
}

"""
order by avg() on columns of table "water_till_now"
"""
input water_till_now_avg_order_by {
  avg: order_by
}

"""
Boolean expression to filter rows from the table "water_till_now". All fields are combined with a logical 'AND'.
"""
input water_till_now_bool_exp {
  _and: [water_till_now_bool_exp]
  _not: water_till_now_bool_exp
  _or: [water_till_now_bool_exp]
  avg: numeric_comparison_exp
}

"""aggregate max on columns"""
type water_till_now_max_fields {
  avg: numeric
}

"""
order by max() on columns of table "water_till_now"
"""
input water_till_now_max_order_by {
  avg: order_by
}

"""aggregate min on columns"""
type water_till_now_min_fields {
  avg: numeric
}

"""
order by min() on columns of table "water_till_now"
"""
input water_till_now_min_order_by {
  avg: order_by
}

"""
ordering options when selecting data from "water_till_now"
"""
input water_till_now_order_by {
  avg: order_by
}

"""
select columns of table "water_till_now"
"""
enum water_till_now_select_column {
  """column name"""
  avg
}

"""aggregate stddev on columns"""
type water_till_now_stddev_fields {
  avg: Float
}

"""
order by stddev() on columns of table "water_till_now"
"""
input water_till_now_stddev_order_by {
  avg: order_by
}

"""aggregate stddev_pop on columns"""
type water_till_now_stddev_pop_fields {
  avg: Float
}

"""
order by stddev_pop() on columns of table "water_till_now"
"""
input water_till_now_stddev_pop_order_by {
  avg: order_by
}

"""aggregate stddev_samp on columns"""
type water_till_now_stddev_samp_fields {
  avg: Float
}

"""
order by stddev_samp() on columns of table "water_till_now"
"""
input water_till_now_stddev_samp_order_by {
  avg: order_by
}

"""aggregate sum on columns"""
type water_till_now_sum_fields {
  avg: numeric
}

"""
order by sum() on columns of table "water_till_now"
"""
input water_till_now_sum_order_by {
  avg: order_by
}

"""aggregate var_pop on columns"""
type water_till_now_var_pop_fields {
  avg: Float
}

"""
order by var_pop() on columns of table "water_till_now"
"""
input water_till_now_var_pop_order_by {
  avg: order_by
}

"""aggregate var_samp on columns"""
type water_till_now_var_samp_fields {
  avg: Float
}

"""
order by var_samp() on columns of table "water_till_now"
"""
input water_till_now_var_samp_order_by {
  avg: order_by
}

"""aggregate variance on columns"""
type water_till_now_variance_fields {
  avg: Float
}

"""
order by variance() on columns of table "water_till_now"
"""
input water_till_now_variance_order_by {
  avg: order_by
}

"""
update columns of table "water"
"""
enum water_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  quantity

  """column name"""
  timestamp

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type water_var_pop_fields {
  quantity: Float
}

"""
order by var_pop() on columns of table "water"
"""
input water_var_pop_order_by {
  quantity: order_by
}

"""aggregate var_samp on columns"""
type water_var_samp_fields {
  quantity: Float
}

"""
order by var_samp() on columns of table "water"
"""
input water_var_samp_order_by {
  quantity: order_by
}

"""aggregate variance on columns"""
type water_variance_fields {
  quantity: Float
}

"""
order by variance() on columns of table "water"
"""
input water_variance_order_by {
  quantity: order_by
}

